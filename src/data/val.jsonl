{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Write to Windows Registry via Go\n\nQuestion:\nI need to write to the Windows Registry via Go, but am unable to find the mechanism to do so.\nI have found that https://github.com/lxn/go-winapi provides read-only access to the Registry in the advapi32.go file.  I have filed a bug report requesting the ability to write to the Registry as well so it makes it into a wishlist or tasklist for someone in the future.\nI think that this ability may not even exist in an existing Go library and that it needs to be created.  On the chance that it already exists, I'm asking here.  If it doesn't exist but you are interested in enhancing go-winapi or another similar library, please do.  Or if you know the mechanics behind writing to the registry, sharing that information so that I (or someone else) can work that into a patch for the go-winapi library would certainly be appreciated.\nIf nothing else, I'll come back here to answer this (if no one else does) if I'm able to get this added to go-winapi or a similar library myself.", "output": "Found at bitbucket.org/kardianos/service/src/service_windows.go, there is working Windows Registry code along with (bonus!) Windows Service management code, too.  Here is a sample of that code:\nvar regSetKeyValueExProc = advapi.MustFindProc(\"RegSetValueExW\")\nfunc regSetKeyValue(h syscall.Handle, keyName string, data interface{}) error {\n        var dataPtr, dataLen, dataType uintptr\n        switch v := data.(type) {\n        case uint32:\n                dataPtr, dataLen = uintptr(unsafe.Pointer(&v)), 4\n                dataType = _REG_DWORD\n        case string:\n                // The comment on MSDN regarding escaping back-slashes, are c-lang specific.\n                // The API just takes a normal NUL terminated string, no special escaping required.\n                dataPtr, dataLen = StringToUTF16PtrLen(v)\n                dataType = _REG_SZ\n        }\n        r0, _, e1 := regSetKeyValueExProc.Call(\n                uintptr(h),\n                uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(keyName))),\n                0,\n                dataType,\n                dataPtr,\n                dataLen,\n        )\n        if r0 != 0 {\n                return e1\n        }\n        return nil\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Pipe input command line to bash interpreter\n\nQuestion:\nI'm writing a small program with an interpreter, I would like to pipe any command that is not recognized by my shell to bash, and print the output as if written in a normal terminal.\nfunc RunExtern(c *shell.Cmd) (string, os.Error) {   \n    cmd := exec.Command(c.Cmd(), c.Args()...)\n    out, err := cmd.Output()\n\n    return string(out), err\n}\n\nthis is what I've written so far, but it only executes a program with its args, I would like to send the whole line to bash and get the output, any idea how to do so ?", "output": "For example, to list directory entries in columns,\npackage main\n\nimport (\n    \"exec\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc BashExec(argv []string) (string, os.Error) {\n    cmdarg := \"\"\n    for _, arg := range argv {\n        cmdarg += `\"` + arg + `\" `\n    }\n    cmd := exec.Command(\"bash\", \"-c\", cmdarg)\n    out, err := cmd.Output()\n    return string(out), err\n}\n\nfunc main() {\n    out, err := BashExec([]string{`ls`, `-C`})\n    if err != nil {\n        fmt.Println(err)\n    }\n    fmt.Println(out)\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Is it possible to bind a method at runtime?\n\nQuestion:\nI have the following construct:\ntype Foo struct {\n    Bar func(foo *Foo) bool\n}\n\nBecause Bar is not really a method, it accepts Foo as parameter (like self in Python's bound methods). I'd however bind it to the struct as a method if there was an easy way. I suspect I could using reflection, but I want to keep it trivial. Is there a trick to bind a function to a struct? How would you do it?\nEdit: I'll add a concrete example of what I'm doing.\ntype Route struct {\n    Matcher func(route *Route, r *http.Request) bool\n}\n\nRoute accepts a custom Matcher function. If not set, a default matcher function is set when the route is registered:\nfunc (mux *ServeMux) HandleRoute(r Route) {\n    // ...\n\n    // Set default matcher.\n    if r.Matcher == nil {\n        r.Matcher = mux.RouteMatcher\n    }\n\n    // ...\n}\n\nThen that function is used to do a matching:\nfunc (mux *ServeMux) Match(r *http.Request) Route {\n    // ...\n\n    if route.Matcher(&route, r) {\n        ...\n    }\n\n    ...\n}\n\nThe function is not bound to the route. My question is if this is a reasonable/idiomatic way to set a custom callable, or if there is a trick to make the function \"bound\" to the struct as a method.", "output": "You don't explain what you are trying to accomplish. What is wrong with this?\npackage main\n\nimport \"fmt\"\n\ntype Foo struct{}\n\nfunc (f *Foo) Bar() bool {\n    return true\n}\n\nfunc main() {\n    var f Foo\n    fmt.Println(f.Bar())\n}\n\nOutput:\ntrue\n\nAre you trying to do something like this?\npackage main\n\nimport \"fmt\"\n\ntype BarFunc func(foo *Foo) bool\n\ntype Foo struct {\n    BarFunc\n}\n\nfunc (f *Foo) Bar() bool {\n    return f.BarFunc(f)\n}\n\nfunc UserBarFunc(foo *Foo) bool { return true }\n\nfunc main() {\n    var f Foo\n    f.BarFunc = UserBarFunc\n    fmt.Println(f.Bar())\n}\n\nOutput:\ntrue"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Updating go websocket library to latest version\n\nQuestion:\nI am running the Go compiler on Ubuntu, installed using sudo apt-get install golang\nI've successfully compiled and executed the code for a Trivial example server (See http://golang.org/pkg/websocket/#Handler )\npackage main\n\nimport (\n    \"http\"\n    \"io\"\n    \"websocket\"\n)\n\n// Echo the data received on the Web Socket.\nfunc EchoServer(ws *websocket.Conn) {\n    io.Copy(ws, ws);\n}\n\nfunc main() {\n    http.Handle(\"/echo\", websocket.Handler(EchoServer));\n    err := http.ListenAndServe(\":12345\", nil);\n    if err != nil {\n        panic(\"ListenAndServe: \" + err.String())\n    }\n}\n\nHowever, I fail to connect to the server with my version of Chromium (16.0.912.77). I assume Chrome has implemented the RFC 6455 Websocket (version 13), but that the go websocket library in the Ubuntu golang package is out of date.\nSo, my question is: How can I update only the websocket package to the latest version?", "output": "The latest version of the Go websocket package is net/websocket at code.google.com/p/go.net/websocket, which requires the Go 1 weekly development release.\nFor Ubuntu golang-weekly: Ubuntu PPA packages for Go.\nFor weekly development release documentation: Go Programming Language."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to lock/synchronize access to a variable in Go during concurrent goroutines?\n\nQuestion:\nIn his answer to this question:  Golang for Windows erratic behavior?\nuser @distributed recommended to lock/synchronize access to a shared variable on concurrent goroutines.\nHow can I do that?\nMore on the issue:\nI get this code (the returned function with a closure on views) running on several goroutines at the same time:\nfunc makeHomeHandler() func(c *http.Conn, r *http.Request) {\n    views := 1\n    return func(c *http.Conn, r *http.Request) {\n        fmt.Fprintf(c, \"Counting %s, %d so far.\", r.URL.Path[1:], views)\n        views++\n    }\n}\n\nIt looks like the IO function takes it's time, and as a result I get this kind of output:\nCounting monkeys, 5 so far.\nCounting monkeys, 5 so far.\nCounting monkeys, 5 so far.\nCounting monkeys, 8 so far.\nCounting monkeys, 8 so far.\nCounting monkeys, 8 so far.\nCounting monkeys, 11 so far.\n\nIt increments fine, but when it gets printed I can see that the operation printing+incrementing is not atomic at all.\nIf I change it to:\nfunc makeHomeHandler() func(c *http.Conn, r *http.Request) {\n    views := 0\n    return func(c *http.Conn, r *http.Request) {\n        views++\n        // I can only hope that other goroutine does not increment the counter \n        // at this point, i.e., right after the previous line and before the \n        // next one are executed!\n        views_now := views\n        fmt.Fprintf(c, \"Counting %s, %d so far.\", r.URL.Path[1:], views_now)\n    }\n}\n\nIt seems to work fine, but I'm not completely sure if it will not fail eventually...", "output": "If a synchronized counter is all you want, then using sync.Mutex is the canonical solution. The sync/atomic package should only be used for low level stuff or when you've measured a serious performance problem.\ntype Counter struct {\n    mu  sync.Mutex\n    x   int64\n}\n\nfunc (c *Counter) Add(x int64) {\n    c.mu.Lock()\n    c.x += x\n    c.mu.Unlock()\n}\n\nfunc (c *Counter) Value() (x int64) {\n    c.mu.Lock()\n    x = c.x\n    c.mu.Unlock()\n    return\n}\n\nfunc makeHomeHandler() func(c http.ResponseWriter, r *http.Request) {\n    var views Counter\n    return func(w http.ResponseWriter, r *http.Request) {\n        fmt.Fprintf(w, \"Counting %s, %d so far.\", r.URL.Path[1:], views.Value())\n        views.Add(1)\n    }\n}\n\nFor your particular problem, I'd suggest defining a new type that satisfies the http.Handler interface, rather than returning a closure. That looks simpler too:\ntype homeHandler struct {\n    mu  sync.Mutex\n    views   int64\n}\n\nfunc (h *homeHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    h.mu.Lock()\n    defer h.mu.Unlock()\n    fmt.Fprintf(w, \"Counting %s, %d so far.\", r.URL.Path[1:], h.views)\n    h.views++\n}\n\nfunc init() {\n    http.Handle(\"/\", new(homeHandler))\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Golang: json.Unmarshal is not returning data correctly\n\nQuestion:\nI have a json file (themes/snow/theme.json)\n{\n    Name:'snow',\n    Bgimage:'background.jpg',\n    Width:600,\n    Height:400,\n    Itemrotation:'20,40',\n    Text:{\n        Fontsize:12,\n        Color:'#ff00ff',\n        Fontfamily:'verdana',\n        Bottommargin:20\n    },\n    Decoration:[\n        {\n            Path:'abc.jpg',\n            X:2,\n            Y:4,\n            Rotation:0\n        },\n        {\n            Path:'def.png',\n            X:4,\n            Y:22,\n            Rotation:10\n        }\n    ]\n}\n\nAnd I have a file that parse the json data\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"encoding/json\"\n    \"io/ioutil\"\n    \"log\"\n)\n\nconst themeDirectory    = \"themes\"\nconst themeJsonFile     = \"theme.json\"\n\ntype TextInfo struct {\n    Fontsize        int\n    Color           string\n    Fontfamily      string\n    Bottommargin    int\n}\n\ntype DecoInfo struct {\n    Path            string\n    X               int\n    Y               int\n    Rotation        int\n}\n\ntype ThemeInfo struct {\n    Name            string\n    Bgimage         string\n    Width           int\n    Height          int\n    Itemrotation    string\n    Text            textInfo\n    Decoration      []decoInfo\n}\n\nfunc main() {\n    var tinfo = parseTheme(\"snow\")\n        //use tinfo to build graphics\n}\n\nfunc parseTheme(themename string) themeInfo {\n    abspath, _ := os.Getwd()\n    filename :=  abspath + \"/\" + themeDirectory + \"/\" + themename + \"/\" + themeJsonFile\n\n    //Check this file exists\n    if _, error := os.Stat(filename); error != nil {\n        if os.IsNotExist(error) {\n            log.Fatal(filename + \" does not exist\")\n            os.Exit(1)\n        }\n    } \n\n    filebyte, error := ioutil.ReadFile(filename) \n    if error != nil { \n        log.Fatal(\"Could not read file \" + filename + \" to parse\")\n        os.Exit(1) \n    } \n\n    var t themeInfo\n    json.Unmarshal(filebyte, &t) \n    fmt.Println(t)\n    return t\n}\n\nYou can see I have 2 lines before the end\n fmt.Println(t)\n\nI am not sure why does it print \n{  0 0  {0   0} []}\n\nI expect it should return me themeInfo in a usable way, so that I can use it for further  processing.What am I doing wrong here?", "output": "Your JSON is not valid. JavaScript allows single quotes; JSON does not. Further, the object keys must be double quoted:\nValid:\n\n{ \"name\": \"Simon\" }\n\nInvalid:\n\n{ name: \"Simon\" }\n{ 'name': \"Simon\" }\n{ \"name\": 'Simon' }\n\nIf you wrap your JSON keys and values with double quotes, you'll see the expected output:\n{snow background.jpg 600 400 20,40 {12 #ff00ff verdana 20} [{abc.jpg 2 4 0} {def.png 4 22 10}]}\n\nFor exmaple,\nconst sampleTheme       = `{\n    \"Name\":\"snow\",\n    \"Bgimage\":\"background.jpg\",\n    \"Width\":600,\n    \"Height\":400,\n    \"Itemrotation\":\"20,40\",\n    \"Text\":{\n        \"Fontsize\":12,\n        \"Color\":\"#ff00ff\",\n        \"Fontfamily\":\"verdana\",\n        \"Bottommargin\":20\n    },\n    \"Decoration\":[\n        {\n            \"Path\":\"abc.jpg\",\n            \"X\":2,\n            \"Y\":4,\n            \"Rotation\":0\n        },\n        {\n            \"Path\":\"def.png\",\n            \"X\":4,\n            \"Y\":22,\n            \"Rotation\":10\n        }\n    ]\n}`\n\nFor the full program, see: http://play.golang.org/p/SLhaLbJcla"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How can I efficiently download a large file using Go?\n\nQuestion:\nIs there a way to download a large file using Go that will store the content directly into a file instead of storing it all in memory before writing it to a file? Because the file is so big, storing it all in memory before writing it to a file is going to use up all the memory.", "output": "I'll assume you mean download via http (error checks omitted for brevity):\nimport (\"net/http\"; \"io\"; \"os\")\n...\nout, err := os.Create(\"output.txt\")\ndefer out.Close()\n...\nresp, err := http.Get(\"http://example.com/\")\ndefer resp.Body.Close()\n...\nn, err := io.Copy(out, resp.Body)\n\nThe http.Response's Body is a Reader, so you can use any functions that take a Reader, to, e.g. read a chunk at a time rather than all at once. In this specific case, io.Copy() does the gruntwork for you."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Go big.Int factorial with recursion\n\nQuestion:\nI am trying to implement this bit of code:\nfunc factorial(x int) (result int) {\n  if x == 0 {\n    result = 1;\n  } else {\n    result = x * factorial(x - 1);\n  }\n  return;\n}\n\nas a big.Int so as to make it effective for larger values of x.\nThe following is returning a value of 0 for     fmt.Println(factorial(r))\nThe factorial of 7 should be 5040?\nAny ideas on what I am doing wrong?\npackage main\n\nimport \"fmt\"\nimport \"math/big\"\n\nfunc main() {\n        fmt.Println(\"Hello, playground\")\n\n    //n := big.NewInt(40)\n    r := big.NewInt(7)\n\n    fmt.Println(factorial(r))\n\n}\n\nfunc factorial(n *big.Int) (result *big.Int) {\n    //fmt.Println(\"n = \", n)\n    b := big.NewInt(0)\n    c := big.NewInt(1)\n\n    if n.Cmp(b) == -1 {\n        result = big.NewInt(1)\n    }\n    if n.Cmp(b) == 0 {\n        result = big.NewInt(1)\n    } else {\n        // return n * factorial(n - 1);\n        fmt.Println(\"n = \", n)\n        result = n.Mul(n, factorial(n.Sub(n, c)))\n    }\n    return result\n}\n\nThis code on go playground: http://play.golang.org/p/yNlioSdxi4", "output": "In your int version, every int is distinct. But in your big.Int version, you're actually sharing big.Int values. So when you say\nresult = n.Mul(n, factorial(n.Sub(n, c)))\n\nThe expression n.Sub(n, c) actually stores 0 back into n, so when n.Mul(n, ...) is evaluated, you're basically doing 0 * 1 and you get back 0 as a result.\nRemember, the results of big.Int operations don't just return their value, they also store them into the receiver. This is why you see repetition in expressions like n.Mul(n, c), e.g. why it takes n again as the first parameter. Because you could also sayresult.Mul(n, c) and you'd get the same value back, but it would be stored in result instead of n.\nHere is your code rewritten to avoid this problem:\nfunc factorial(n *big.Int) (result *big.Int) {\n    //fmt.Println(\"n = \", n)\n    b := big.NewInt(0)\n    c := big.NewInt(1)\n\n    if n.Cmp(b) == -1 {\n        result = big.NewInt(1)\n    }\n    if n.Cmp(b) == 0 {\n        result = big.NewInt(1)\n    } else {\n        // return n * factorial(n - 1);\n        fmt.Println(\"n = \", n)\n        result = new(big.Int)\n        result.Set(n)\n        result.Mul(result, factorial(n.Sub(n, c)))\n    }\n    return\n}\n\nAnd here is a slightly more cleaned-up/optimized version (I tried to remove extraneous allocations of big.Ints): http://play.golang.org/p/feacvk4P4O"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How do I put a vector inside of a struct in Go?\n\nQuestion:\nI'm trying to put a vector variable inside a struct in Google's Go programming language. This is what I have so far:\nWant:\ntype Point struct { x, y int }\ntype myStruct struct {\n myVectorInsideStruct vector;\n}\n\nfunc main(){\n myMyStruct := myStruct{vector.New(0)};\n myPoint := Point{2,3};\n myMyStruct.myVectorInsideStruct.Push(myPoint);\n}\n\nHave:\ntype Point struct { x, y int }\n\nfunc main(){\nmyVector := vector.New(0);\nmyPoint := Point{2,3};\nmyVector.Push(myPoint);\n}\n\nI can get the vector to work in my main function just fine, but I want to encapsulate it inside a struct for easier use.", "output": "I'm not sure whether this is what you want, so leave a comment if it doesn't work:\npackage main\n\nimport \"container/vector\";\n\ntype Point struct { x, y int };\n\ntype mystruct struct {\n    myVectorInsideStruct * vector.Vector;\n}\n\nfunc main() {\n    var myMyStruct mystruct;\n    myMyStruct.myVectorInsideStruct = new(vector.Vector);\n    myPoint := Point{2,3};\n    myMyStruct.myVectorInsideStruct.Push(myPoint);\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How can I launch a process that is not a file in Go (e.g. open a web page)\n\nQuestion:\nI want to open a web browser:\nc, err := exec.Command(\"http://localhost:4001\").Output()\nif err != nil {\n    fmt.Printf(\"ERROR: %v, %v\\n\",err,c)\n} else {\n    fmt.Printf(\"OK:%v\\n\",c)\n}\n\nand I get the error \nERROR: exec: \"http://localhost:4001\": file does not exist\n\nEdit: What I want to achieve is the same as in Windows and C# when you do: \nProcess.Start(\"http://localhost:4001\")\n\nWith it a new instance of your default browser will launch showing the URL", "output": "\"http://localhost:4001/\" is a URL, it can not be executed, but you can execute a web browser (e.g. firefox) and pass the URL as first argument.\nOn Windows, OS X, and Linux helper programs exist which can be used to start the default web browser. I guess there is a similar thing for FreeBSD and Android, but I am not sure about it. The following snippet should work on Windows, OS X, and most Linux distros:\nvar err error\nswitch runtime.GOOS {\ncase \"linux\":\n    err = exec.Command(\"xdg-open\", \"http://localhost:4001/\").Start()\ncase \"windows\", \"darwin\":\n    err = exec.Command(\"open\", \"http://localhost:4001/\").Start()\ndefault:\n    err = fmt.Errorf(\"unsupported platform\")\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: async reply in registry pattern\n\nQuestion:\nI'm learning go, and I would like to explore some patterns.\nI would like to build a Registry component which maintains a map of some stuff, and I want to provide a serialized access to it:\nCurrently I ended up with something like this:\ntype JobRegistry struct {\n  submission chan JobRegistrySubmitRequest\n  listing chan JobRegistryListRequest\n}\n\ntype JobRegistrySubmitRequest struct {\n  request JobSubmissionRequest\n  response chan Job\n}\n\ntype JobRegistryListRequest struct {\n  response chan []Job\n}\n\nfunc NewJobRegistry() (this *JobRegistry) {\n  this = &JobRegistry{make(chan JobRegistrySubmitRequest, 10), make(chan JobRegistryListRequest, 10)}\n\n  go func() {\n    jobMap := make(map[string] Job)\n\n    for {\n        select {\n        case sub := <- this.submission:\n            job := MakeJob(sub.request) // ....\n\n            jobMap[job.Id] = job\n            sub.response <- job.Id\n\n        case list := <- this.listing:\n\n            res := make([]Job, 0, 100)\n            for _, v := range jobMap {\n                res = append(res, v)\n            }\n            list.response <- res\n\n        }\n\n        /// case somechannel....\n     }\n   }()\n\n   return\n}\n\nBasically, I encapsulate each operation inside a struct, which carries\nthe parameters and a response channel.\nThen I created helper methods for end users:\nfunc (this *JobRegistry) List() ([]Job, os.Error) {\n    res := make(chan []Job, 1)\n    req := JobRegistryListRequest{res}\n    this.listing <- req\n    return <-res, nil // todo: handle errors like timeouts\n}\n\nI decided to use a channel for each type of request in order to be type safe.\n\nThe problem I see with this approach are:\n\nA lot of boilerplate code and a lot of places to modify when some param/return type changes\nHave to do weird things like create yet another wrapper struct in order to return errors from within the handler goroutine. (If I understood correctly there are no tuples, and no way to send multiple values in a channel, like multi-valued returns)\n\nSo, I'm wondering whether all this makes sense, or rather just get back to good old locks.\nI'm sure that somebody will find some clever way out using channels.", "output": "I'm not entirely sure I understand you, but I'll try answering never the less.\nYou want a generic service that executes jobs sent to it. You also might want the jobs to be serializable.\nWhat we need is an interface that would define a generic job.\ntype Job interface {\n    Run()\n    Serialize(io.Writer)\n}\n\nfunc ReadJob(r io.Reader) {...}\n\ntype JobManager struct {\n    jobs map[int] Job\n    jobs_c chan Job      \n}\n\nfunc NewJobManager (mgr *JobManager) {\n    mgr := &JobManager{make(map[int]Job),make(chan Job,JOB_QUEUE_SIZE)}\n    for {\n        j,ok := <- jobs_c\n        if !ok {break}\n        go j.Run()\n    }\n}\n\ntype IntJob struct{...}\nfunc (job *IntJob) GetOutChan() chan int {...}\nfunc (job *IntJob) Run() {...}\nfunc (job *IntJob) Serialize(o io.Writer) {...}\n\nMuch less code, and roughly as useful.\nAbout signaling errors with an axillary stream, you can always use a helper function.\ntype IntChanWithErr struct {\n    c chan int\n    errc chan os.Error\n}\nfunc (ch *IntChanWithErr) Next() (v int,err os.Error) {\n    select {\n        case v := <- ch.c // not handling closed channel\n        case err := <- ch.errc\n    }\n    return\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Converting slice of structs to slice of empty interface\n\nQuestion:\nI'm trying to assign a slice of structs to a slice []interface{} (to pass into AppEngine's datastore.PutMulti. However, this is causing compilation errors as the two types are apparently incompatible:\ncannot use type[]*MyStruct as type []interface { } in assignment\nBasically I have:\nvar src []*MyStruct\nvar dest []interface{}\n…\ndest = src  // This line fails.\n\nIs there anyway to copy src into dest without copying each element one-at-a-time?", "output": "You're going to have to copy one-at-a-time. There's no way around it.\nIf it helps to accept this, you should think about the fact that wrapping a struct in an interface really does actually wrap it at the memory level. An interface contains a pointer to the original type and a descriptor for the type itself. When casting a single struct to an interface, you're really wrapping it. So copying them one-at-a-time is necessary in order to wrap the structs up in the interface."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Go template examples\n\nQuestion:\nWhat website has some good, up to date resources on using Go html/templates, especially in regard to parsing html files and handling lists? I came across the Hoka Poka website, but it seems to be out of date.", "output": "http://jan.newmarch.name/go/ and http://golangtutorials.blogspot.com/2011/06/go-templates.html"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How do I encrypt with an RSA private key read from a PEM file using the Go programming language?\n\nQuestion:\nHow do I do the equivalent of the following C++ code in go?\nRSA *key = PEM_read_RSAPrivateKey(f, NULL, NULL, NULL);\nstd::vector<CK_BYTE> out(128);\nRSA_private_encrypt(in.size(), &in[0], &out[0], key, RSA_PKCS1_PADDING)\n\nI've looked at the Go rsa package.  It looks like EncryptPKCS1v15() may be the equivalent of RSA_private_encrypt().  But I don't see how to create a PrivateKey object other than with GenerateKey(), which (one can confirm by looking at the source) generates one using random prime numbers.\nDo I need to figure out how to decode a PEM file so pull out the PrivateKey fields' values?\nUpdate: The equivalent to the above C++ code in Python is:\nfrom M2Crypto import RSA\nrsa_private_key = RSA.load_key('privkey.pem')\nencrypted = rsa_private_key.private_encrypt(digest, RSA.pkcs1_padding)\n\nIs there an existing equivalent in Go?", "output": "The equivalent function appears to be SignPKCS1v15. The function ParsePKCS1PrivateKey in the crypto/x509 package appears to be the closest to what you need to read in your existing private key, but I'm not sure the PEM format is exactly compatible, which it must be for this to work."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Reading log files as they're updated in Go\n\nQuestion:\nI'm trying to parse some log files as they're being written in Go but I'm not sure how I would accomplish this without rereading the file again and again while checking for changes.\nI'd like to be able to read to EOF, wait until the next line is written and read to EOF again, etc. It feels a bit like how tail -f looks.", "output": "I have written a Go package -- github.com/hpcloud/tail -- to do exactly this.\nt, err := tail.TailFile(\"/var/log/nginx.log\", tail.Config{Follow: true})\nfor line := range t.Lines {\n    fmt.Println(line.Text)\n}\n\n...\nQuoting kostix's answer:\n\nin real life files might be truncated, replaced or renamed (because that's what tools like logrotate are supposed to do).\n\nIf a file gets truncated, it will automatically be re-opened. To support re-opening renamed files (due to logrotate, etc.), you can set Config.ReOpen, viz.:\nt, err := tail.TailFile(\"/var/log/nginx.log\", tail.Config{\n    Follow: true,\n    ReOpen: true})\nfor line := range t.Lines {\n    fmt.Println(line.Text)\n}\n\nConfig.ReOpen is analogous to tail -F (capital F):\n -F      The -F option implies the -f option, but tail will also check to see if the file being followed has been\n         renamed or rotated.  The file is closed and reopened when tail detects that the filename being read from\n         has a new inode number.  The -F option is ignored if reading from standard input rather than a file."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Visibility in sub-packages\n\nQuestion:\nHow's the visibility of members from a sub-package to its root package?\nThis is what I mean:\nfoo          // the \"root\" package\nfoo/utils    // a sub-package\nfoo/tools    // another sub-package\n\nCan foo access private members of foo/utils and foo/tools or do they act as separate, independant packages?", "output": "Go has no concept of sub-directories nor sub-packages. Packages are separate from each other. The import path \"foo/utils\" is just an import path (a method of how to find the package) - the string \"foo/utils\" has no significance other than locating the package on local disk or in the Internet.\nfoo cannot access private members of foo/utils.\nIn Go1, each directory in a source tree corresponds to a single package. More about this can be found here: the go command."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: GAE Go Version 3 API error\n\nQuestion:\nI'm attempting to update a pretty trivial web-app to version 3 of Go GAE. I get this error whenever I query the datastore for a specific object that I know is there, but other queries seem to fail silently. Has the way you use the datastore changed (function parameters excluded - my new code does compile!)?\nError = API error 4 (datastore_v3: NEED_INDEX): no matching index found.\nThanks", "output": "You're attempting to execute a query that requires a custom index, but you haven't specified one (or it hasn't finished building). You should fully exercise your app on your local dev_appserver, then upload your app to update the index definitions."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Booleans always false when Putting entities in Google App Engine datastore - Golang\n\nQuestion:\nFor some reason when I attempt to store boolean data in the Google Apps datastore, it always stores as false.\nMy entity definition looks like this:\ntype Link struct {\n  Name          string    //Coloquial label for link. Set by original User.\n  ...\n  isOpen        bool      //Tells us whether anyone can rewrite the link. Set by original User.\n  isPerminant   bool      //Tells us whether link should be saved forever.\n  isFlagged     bool      //Tells us whether the content has ever been flagged inappropriate.\n}\n\nI create an object and assign values like so:\n//Create Link from form data\nl   := Link{\n  Name:         r.FormValue(\"name\"),\n  ...\n  isOpen:       r.FormValue(\"open\")==\"on\",        \n  isPerminant:  r.FormValue(\"perminant\")==\"on\",\n  isFlagged:    r.FormValue(\"flagged\")==\"on\",\n}\n\nI verify the data by running the following:\n//Put the Link in the datastore\nlKey, err := datastore.Put(c, datastore.NewIncompleteKey(c, \"Link\", nil), &l)\nif err != nil {\n  http.Error(w, err.Error(), http.StatusInternalServerError)\n  return\n}\n\nvar newLink Link\nif err = datastore.Get(c, lKey, &newLink); err != nil {\n  http.Error(w, err.Error(), http.StatusInternalServerError)\n  return\n}\n\nnewLink output value: {[name] ... false false false}\n\nEven if I hard code in a true value for one of the is[...] properties, they all still remain false! WHHHHHHYYYY???", "output": "Try capitalizing the I in Is:\ntype Link struct {\n    Name        string //Coloquial label for link. Set by original User.\n    IsOpen      bool   //Tells us whether anyone can rewrite the link. Set by original User.\n    IsPerminant bool   //Tells us whether link should be saved forever.\n    IsFlagged   bool   //Tells us whether the content has ever been flagged inappropriate.\n}\n\n.\n//Create Link from form data\nl := Link{\n    Name:        r.FormValue(\"name\"),\n    IsOpen:      r.FormValue(\"open\") == \"on\",\n    IsPerminant: r.FormValue(\"perminant\") == \"on\",\n    IsFlagged:   r.FormValue(\"flagged\") == \"on\",\n}\n\nFor a field to be saved to the datastore it must be exported. I.e. begin with an uppercase letter. For more information please read the Names section of Effective Go"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How do you use cgo WITHOUT using make?\n\nQuestion:\nI use a custom build tool to compile go projects and I need a way to use cgo in my project. \nThe problem is that the cgo documentation only tells you how to use it with make. \nWhat I really need to know is which generated files to process with which tools and in what order it needs to be done. I tried to read make.pkg in the go source dir but my best effort fails.\nMy test dll is very simple, a single function that returns 1 every time it is called and the go code to use this function is similarly simple.\nThe output from the console produced by a successful run of make on a cgo project would be very helpful.", "output": "Output of running make on 32-bit Linux in directory misc/cgo/life:\n# gomake _obj/life.a\nCGOPKGPATH= cgo --  life.go \ntouch _obj/_cgo_run\n8g  -o _go_.8  _obj/life.cgo1.go _obj/_cgo_gotypes.go\n8c -FVw -I ${GOROOT}/pkg/linux_386 -I . -o \"_cgo_defun.8\" _obj/_cgo_defun.c\ngcc -m32 -I . -g -fPIC -O2 -o _cgo_main.o -c   _obj/_cgo_main.c\ngcc -m32 -g -fPIC -O2 -o c-life.o -c   c-life.c\ngcc -m32 -I . -g -fPIC -O2 -o life.cgo2.o -c   _obj/life.cgo2.c\ngcc -m32 -I . -g -fPIC -O2 -o _cgo_export.o -c   _obj/_cgo_export.c\ngcc -m32 -g -fPIC -O2 -o _cgo1_.o _cgo_main.o c-life.o life.cgo2.o _cgo_export.o  \ncgo -dynimport _cgo1_.o >_obj/_cgo_import.c_ && mv -f _obj/_cgo_import.c_ _obj/_cgo_import.c\n8c -FVw -I . -o \"_cgo_import.8\" _obj/_cgo_import.c\nrm -f _obj/life.a\ngopack grc _obj/life.a _go_.8  _cgo_defun.8 _cgo_import.8 c-life.o  life.cgo2.o _cgo_export.o\n\nThe line cgo -- life.go creates the following files:\n_obj/_cgo_.o\n_obj/life.cgo1.go\n_obj/life.cgo2.c\n_obj/_cgo_gotypes.go\n_obj/_cgo_defun.c\n_obj/_cgo_main.c\n_obj/_cgo_flags\n_obj/_cgo_export.c\n_cgo_export.h"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Parameter passing in Go\n\nQuestion:\nSuppose I have a method of type http.HandleFunc\ntype HandlerFunc func(ResponseWriter, *Request)\n\nAnd I want to wrap it around another method of the same type, somewhat like this:\nfunc MyWrapper(res http.ResponseWriter, req *http.Request) {\n\n    // do stuff\n\n    AnotherMethod(res, req) // <- question refers to this line\n\n    // do more stuff\n\n}\n\nfunc AnotherMethod(res http.ResponseWriter, req *http.Request) {\n\n    // main logic\n\n}\n\nIf I'm getting this right; when I call AnotherMethod(res, req) I'm passing a copy of (the value of) res to AnotherMethod, meaning that this object is now duplicated in memory.\nIs there a way I could pass a pointer to res to AnotherMethod and then dereference there, in order to not copy the value of res? or am I not understanding something?\n(Working with a pointer to (the value of) res inside AnotherMethod won't work because the receivers of all methods in http.ResponseWriter are values and not pointers)", "output": "http.ResponseWriter is an interface type. Which means it can be both a reference or value type, depending on what the underlying type is and how it implements the interface.\nIn this case, res is an instance of the unexported type *http.response. As you can see, it is a pointer type, which means you can pass it around without creating a copy of the whole structure.\nTo see what real type is held inside an interface value you are receiving, you can do this: fmt.Printf(\"%T\\n\", res). It should print: *http.resonse.\nFor more information on how interface types work in Go, I recommend reading the Go specification on the subject."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: What is the point of slice type in Go?\n\nQuestion:\nI have read this but still not fully aware of the advantage of slice against array.So I am expecting somebody in SO explain better than it and I am sure you can :)", "output": "Slices have a lot of uses over arrays, several of which other posters have already mentioned.\n\nSlices can operate in many ways like pointers.\n\n\nMultiple slices can \"point\" to the same base array\nSlices are passed by reference, but since a slice itself is a pointer it can be used to pass \"arrays\" around much more efficiently since the entire array doesn't need to be copied.\n\nHowever, unlike pointers, slices provide additional buffer safety\n\n\nSlice underflows and overflows trigger exceptions, rather than allowing you an unsafe ability to access other areas of memory.\nSlices allow you to limit access to only certain areas of an array. This can be extremely useful in working with subsets.\n\nThe length of a slice is dynamically determined at runtime, unlike arrays which have their sizes fixed at compile time. Also, slices can be dynamically resized at runtime."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: What's the closure scoping difference between short variable declarations and long ones in Go?\n\nQuestion:\nFrom my reading of the spec:\n\nA short variable declaration ... is a shorthand for a regular variable\n  declaration with initializer expressions but no types...\n\nhttp://golang.org/ref/spec\nI would have thought the two were identical:\nvar f func()\nf = func() {\n    ...\n}\n\nand\nf := func() {\n    ...\n}\n\nBut it seems like they're not. I was trying to wrap a self-recursive function inside of an outer function, but this works:\nfunc myOuter() {\n    var f func()\n\n    f = func() {\n        f()\n    }\n\n    f()\n}\n\nBut this doesn't, saying undefined: f in the inner function.\nfunc myOuter() {\n    f := func() {\n        f()\n    }\n\n    f()\n}\n\nSo what is the difference? \nIs there any way to write this with the short-form declaration or I do I have to write it out long-hand?", "output": "f := func() { /* ... */ } is identical to var f func() = func() { /* ... */ } (but only the later one is allowed at the package level). In your specific case, neither of the two variants will work, since the statement will be evaluated from right to left. The solution is - as you have already suggested - to split the statement into two. One for declaring the variable and another for assigning the recursive function to it."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Unnamed arrays in structs in Go\n\nQuestion:\nSo I can have\nstruct {\n    int\n    x []int\n}\n\nHowever,\nstruct {\n    int\n    []int\n}\n\nwill result in a syntax error: unexpected [, expecting }. Is there a way of having unnamed arrays in structs in Go? If so, what's the correct syntax?", "output": "No, the type of an anonymous field must be a type name or a pointer to a type name. You could declare a new type name that is the same as an array type, and then it would work, but it wouldn't be exactly the same."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to decode JSON with type convert from string to float64\n\nQuestion:\nI need to decode a JSON string with the float number like:\n{\"name\":\"Galaxy Nexus\", \"price\":\"3460.00\"}\n\nI use the Golang code below:\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\ntype Product struct {\n    Name  string\n    Price float64\n}\n\nfunc main() {\n    s := `{\"name\":\"Galaxy Nexus\", \"price\":\"3460.00\"}`\n    var pro Product\n    err := json.Unmarshal([]byte(s), &pro)\n    if err == nil {\n        fmt.Printf(\"%+v\\n\", pro)\n    } else {\n        fmt.Println(err)\n        fmt.Printf(\"%+v\\n\", pro)\n    }\n}\n\nWhen I run it, get the result:\njson: cannot unmarshal string into Go value of type float64\n{Name:Galaxy Nexus Price:0}\n\nI want to know how to decode the JSON string with type convert.", "output": "The answer is considerably less complicated.  Just add tell the JSON interpeter it's a string encoded float64 with ,string (note that I only changed the Price definition):\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\ntype Product struct {\n    Name  string\n    Price float64 `json:\",string\"`\n}\n\nfunc main() {\n    s := `{\"name\":\"Galaxy Nexus\", \"price\":\"3460.00\"}`\n    var pro Product\n    err := json.Unmarshal([]byte(s), &pro)\n    if err == nil {\n        fmt.Printf(\"%+v\\n\", pro)\n    } else {\n        fmt.Println(err)\n        fmt.Printf(\"%+v\\n\", pro)\n    }\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Go array slice from function return statement\n\nQuestion:\nI have the following functions:\nfunc (c *Class)A()[4]byte\nfunc B(x []byte)\n\nI want to call\nB(c.A()[:])\n\nbut I get this error:\ncannot take the address of c.(*Class).A()\n\nHow do I properly get a slice of an array returned by a function in Go?", "output": "The value of c.A(), the return value from a method, is not addressable.\n\nAddress operators\nFor an operand x of type T, the address operation &x generates a\n  pointer of type *T to x. The operand must be addressable, that is,\n  either a variable, pointer indirection, or slice indexing operation;\n  or a field selector of an addressable struct operand; or an array\n  indexing operation of an addressable array. As an exception to the\n  addressability requirement, x may also be a composite literal.\nSlices\nIf the sliced operand is a string or slice, the result of the slice\n  operation is a string or slice of the same type. If the sliced operand\n  is an array, it must be addressable and the result of the slice\n  operation is a slice with the same element type as the array.\n\nMake the value of c.A(), an array, addressable for the slice operation [:]. For example, assign the value to a variable; a variable is addressable.\nFor example,\npackage main\n\nimport \"fmt\"\n\ntype Class struct{}\n\nfunc (c *Class) A() [4]byte { return [4]byte{0, 1, 2, 3} }\n\nfunc B(x []byte) { fmt.Println(\"x\", x) }\n\nfunc main() {\n    var c Class\n    // B(c.A()[:]) // cannot take the address of c.A()\n    xa := c.A()\n    B(xa[:])\n}\n\nOutput:\nx [0 1 2 3]"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to get CPU usage\n\nQuestion:\nMy Go program needs to know the current cpu usage percentage of all system and user processes.\nHow can I obtain that?", "output": "I had a similar issue and never found a lightweight implementation. Here is a slimmed down version of my solution that answers your specific question. I sample the /proc/stat file just like tylerl recommends. You'll notice that I wait 3 seconds between samples to match top's output, but I have also had good results with 1 or 2 seconds. I run similar code in a loop within a go routine, then I access the cpu usage when I need it from other go routines.  \nYou can also parse the output of top -n1 | grep -i cpu to get the cpu usage, but it only samples for half a second on my linux box and it was way off during heavy load. Regular top seemed to match very closely when I synchronized it and the following program:\npackage main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"strconv\"\n    \"strings\"\n    \"time\"\n)\n\nfunc getCPUSample() (idle, total uint64) {\n    contents, err := ioutil.ReadFile(\"/proc/stat\")\n    if err != nil {\n        return\n    }\n    lines := strings.Split(string(contents), \"\\n\")\n    for _, line := range(lines) {\n        fields := strings.Fields(line)\n        if fields[0] == \"cpu\" {\n            numFields := len(fields)\n            for i := 1; i < numFields; i++ {\n                val, err := strconv.ParseUint(fields[i], 10, 64)\n                if err != nil {\n                    fmt.Println(\"Error: \", i, fields[i], err)\n                }\n                total += val // tally up all the numbers to get total ticks\n                if i == 4 {  // idle is the 5th field in the cpu line\n                    idle = val\n                }\n            }\n            return\n        }\n    }\n    return\n}\n\nfunc main() {\n    idle0, total0 := getCPUSample()\n    time.Sleep(3 * time.Second)\n    idle1, total1 := getCPUSample()\n\n    idleTicks := float64(idle1 - idle0)\n    totalTicks := float64(total1 - total0)\n    cpuUsage := 100 * (totalTicks - idleTicks) / totalTicks\n\n    fmt.Printf(\"CPU usage is %f%% [busy: %f, total: %f]\\n\", cpuUsage, totalTicks-idleTicks, totalTicks)\n}\n\nIt seems like I'm allowed to link to the full implementation that I wrote on bitbucket; if it's not, feel free to delete this. It only works on linux so far, though: systemstat.go"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How do I debug a program written in the Go language?\n\nQuestion:\nHow do I debug a Go program? I have been using the Gedit Go IDE,  but it doesn't have debugging.  Is there a way to step though my code and inspect memory?  Or am I stuck with print statements?  Can I use OutputDebugString?", "output": "Update: There is now an official page in the docs on Debugging Go Code with GDB. Much has changed since this answer was written, and several of the limitations listed below have been removed. I'm leaving the rest of this answer for posterity, but if you want to debug Go code, follow the link above.\nThe Go linkers now emit DWARF debugging symbols that can be interpreted by gdb version 7.x.\nHighlight from the blog post linked above:\nYou can...\n\nload a Go program in GDB version 7.x\nlist all Go, C, and assembly source files by line (parts of the Go runtime are written in C and assembly),\nset breakpoints by line and step through the code,\nprint stack traces and inspect stack frames, and\nfind the addresses and print the contents of most variables.\n\nThere are still some inconveniences:\n\nThe emitted DWARF code is unreadable by the GDB version 6.x that ships with Mac OS X. We would gladly accept patches to make the DWARF output compatible with the standard OS X GDB, but until that’s fixed you’ll need to download, build, and install GDB 7.x to use it under OS X. The source can be found at http://sourceware.org/gdb/download/. Due to the particulars of OS X you’ll need to install the binary on a local file system with chgrp procmod and chmod g+s.\nNames are qualified with a package name and, as GDB doesn't understand Go packages, you must reference each item by its full name. For example, the variable named v in package main must be referred to as 'main.v', in single quotes. A consequence of this is that tab completion of variable and function names does not work.\nLexical scoping information is somewhat obfuscated. If there are multiple variables of the same name, the nth instance will have a suffix of the form ‘#n’. We plan to fix this, but it will require some changes to the data exchanged between the compiler and linker.\nSlice and string variables are represented as their underlying structure in the runtime library. They will look something like {data = 0x2aaaaab3e320, len = 1, cap = 1}. For slices, you must dereference the data pointer to inspect the elements.\n\nSome things don't work:\n\nChannel, function, interface, and map variables cannot be inspected.\nOnly Go variables are annotated with type information; the runtime's C variables are not.\nWindows and ARM binaries do not contain DWARF debugging information and, as such, cannot be inspected with GDB."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Using an operator in place of a function\n\nQuestion:\nIs it possible to use an operator in place of a function in go?\nFor example, in the following code is it possible to replace add with +?\npackage main\n\nimport \"fmt\"\n\nvar cur, prev int = 1, 1\n\nfunc fib(f func(int, int) int) int {\n    return f(cur, prev)\n}\n\nfunc main() {\n    add := func(x int, y int) int { return x + y };\n    fmt.Println(fib(add))\n}\n\nIf it's not possible to use operators as functions, then I would appreciate a link to the documentation clarifying this.", "output": "Operators are not first-class values in Go (nor most other languages), so no, you cannot pass them as arguments. Notice that even the Go documentation uses a func(x,y int) int { return x+y } in its examples.\nAlso note that the grammar for operators does not allow any options for an operator without a corresponding expression to operate on."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Why does Go use its own Code generator?\n\nQuestion:\nThe current, official compiler for Go (http://code.google.com/p/go/) currently uses a handcrafted, arguably arcane code generator, which includes injecting custom sections into the ELF Binary.\nThis approach has spawned quite a few bugs related to utilities that directly read and/or write ELF Information, such as ldd, objdump or strip.\nI believe that this could have been prevented by using a welltested crossplatform code generator, such as LLVM, and then just use linking facilities shipped with the OS, such as ld on Unix/Linux (or ld.exe on windows w/ MinGW), or link.exe on Windows with Visual Studio.\nSo why does Go use its very own code generator? Is it really just reinventing the wheel? Or are there more important reasons behind it?", "output": "For information on how to use gccgo, a more traditional compiler using the GCC back end, see Setting up and using gccgo.\nThe Go Language Specification is compiler agnostic. You can choose from the available compilers, write one yourself, or contribute to the LLVM Go frontend project.\nFor an historical perspective on the Go compiler technology, read the answer to this question: What compiler technology is used to build the compilers?"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to read input from a HTML form and save it in a file - Golang\n\nQuestion:\nI am trying to set up a very simple web server where the user access a site and writes a string and an int.Then I want to save these two inputs, my idea was to do it to a text file that also can be displayed in the browser: .../textfile/\nI don´t know what the norm on SO is on how much code is OK to post but here is what I have so far:\ntype Person struct {\n    name  string\n    hours int\n}\n\nconst filename string = \"timelister\"\n\nfunc upload(w http.ResponseWriter, r *http.Request) {\n    t, _ := template.ParseFiles(\"upload.html\")\n    t.Execute(w, nil)\n}\n\nfunc (person *Person) open() {\n    newFilename := filename + \".txt\"\n    _, err := os.OpenFile(newFilename, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0666)\n    if err != nil {\n        log.Fatal(\"Open Filename: \", err)\n    }\n}\n\nfunc returnInput() //want to implement this\nfunc saveInput() //want to implemet this\n\n\nfunc main() {\n    http.HandleFunc(\"/\", upload)\n    http.ListenAndServe(\":8080\", nil)\n\n}\n\nAnd my HTML-form: (without all the formating)\n     Name: <input type=\"text\" name=\"Name\">\n        <input type=\"submit\" value=\"submit\"></br>\n     Hours: <input type=\"text\" name=\"Hours\">\n            <input type=\"submit\" value=\"submit\">\n\nSo my initial thoughts was to implement two functions returnInput() and saveInput() but maybe there are som built in functions that are easier to use?\nIf somebody could point me in the right direction on how to save the input from the HTML form than I would be very greatful! Thanks in advance.", "output": "You'll need to pick a format to write to the file. Let's pick JSON for no reason in particular. So given a form like:\n<form action=\"/save\" method=\"post\"> ... </form>\n\nyou could have the following handler\nimport (\n    \"strconv\"\n    \"http\"\n    \"os\"\n    \"encoding/json\"\n)\n\ntype Data struct {\n    Name string\n    Hours int\n}\n\nfunc save(w http.ResponseWriter, r *http.Request) {\n    name := r.FormValue(\"Name\")\n    hours, err := strconv.Atoi(r.FormValue(\"Hours\"))\n    if err != nil {\n        http.Error(w, err.Error(), 500)\n        return\n    }\n\n    data := &Data{name, hours}\n\n    b, err := json.Marshal(data)\n    if err != nil {\n        http.Error(w, err.Error(), 500)\n        return\n    }\n\n    f, err := os.Open(\"somefile.json\")\n    if err != nil {\n        http.Error(w, err.Error(), 500)\n        return\n    }\n\n    f.Write(b)\n    f.Close()\n}\n\nfunc init() {\n    http.HandleFunc(\"/save\", save)\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Go code contribution: license and patent implications?\n\nQuestion:\nI've been reviewing the contributions documentation for Google new language, and was curious about the idea of contributing a new package.  It states that this should be included at the top of contributed source code:\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\nMy understanding of a BSD-style license is that it essentially means that the user needs to attribute the code to you, but can do whatever else they want.\nFurther down it says: \n\nIf you are the copyright holder, you will need to agree to the individual contributor license agreement...\n\nIn the \"individual contributor license agreement\", it says that Google has patentable rights to the contributed code:\n\nYou hereby grant to Google and to recipients of software distributed by Google a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contribution(s) alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted.\n\nTo what extent does Google own any Go contributions?  Do they have full rights to profit from these contributions?", "output": "To what extent does Google own any Go contributions?\n\nYou are not required to transfer copyright to Google.  You still OWN the copyright.\nYou are not required to transfer ownership of patents to Google.  You still OWN the patents.\nIn short Google does not OWN any IP that they didn't already own.\nBut you do grant Google the unlimited right to use and distribute your contributions, and you grant the right to use to downstream folks.  Clause 2 covers copyrights, and clause 3 covers patent rights.  Moreover you grant this as an irrevocable license (i.e. you cannot change your mind) and for free.\n\nDo they have full rights to profit\n  from these contributions?\n\nThere is no such a thing as \"a right to profit\" in a legal or moral sense.  Hence \"full rights to profit\" is not a valid characterization of the rights that you currently have.\nBy granting Google non-exclusive, non-revocable copyright and patent licenses, your remaining rights are no longer exclusive.  Google will be able to profit your contributions, but so will you.  You will have reduced your scope for personal profit, but that was not ever a \"right\"."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to enable autocomplete in GoClipse?\n\nQuestion:\nThe instructions how to install GoClipse have been followed.\nI'm not getting any autocomplete stuff happening at all, either for local packages that I write, for built in stuff, or for GAE stuff (I have downloaded Go src to the SDK folder as the wiki states).\nAre there any settings that I can check to ensure it is set up correctly? Is autocomplete supposed to work in the current version?", "output": "As the GoClipse with AppEngine article you linked to says:\n\nWe assume the reader has a working copy of GoClipse running in their Eclipse environment.\n\nso that’s not the article you want to refer to. Instead, check for GoClipse.\nThe auto completion is named content assist in eclipse. The GoClipse features state:\n\nNow delivered with content assist via Gocode for Windows, OS X 64bit, and Linux 64bit.\n\nGocode is an auto-completion daemon. So you will also have to install and run that one besides your eclipse + GoClipse."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to use arbitrary length sequences of values as map keys in Go?\n\nQuestion:\nEdit: Jeremy Wall helped me realize I had asked a question more specific than I intended; here's a better version. \nSay I want to represent a table associating of values of some type B to sequences of values of some type A for which equality is defined. What is the best way to do that in Go?\nObviously for the table I'd want to use a Go map, but what can I use for the sequences of values of type A? Slices cannot be used as keys for maps in Go; arrays can, but the length of an array is a part of it's type and I'm interested in being able to use sequences of length determined at runtime. I could (1) use arrays of A declaring a maximum length for them or (2) use slices of A, serialize them to strings for use as keys (this technique is familiar to Awk and Lua programmers...). Is there a better work around for this \"feature\" of Go than the ones I've described?\nAs pointed out by Jeremy Wall in answer to my original version of the question, where I had A = int, option (2) is pretty good for integers, since you can use slices of runes for which conversion to string is just a cast.", "output": "Will a sequence of rune instead of integers work for you? runes are uint32 and the conversion to a string is just a cast:\npackage main\n\nimport \"fmt\"\n\ntype myKey struct {\n  seq []int\n}\n\nfunc main() {\n    m := make(map[string]string)\n    key := []rune{1, 2}\n    m[string(key)] = \"foo\"\n    fmt.Print(\"lookup: \", m[string(key)])\n}\n\nYou can play with this code here: http://play.golang.org/p/Kct1dum8A0"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Cast from renamed type in google go\n\nQuestion:\nI'm trying to write suitable method of converting appengine/datastore.Time type to string.\nThis type is declared as type Time int64\nBut when i'm trying to use it as int64 value:\nlocalTime := time.SecondsToLocalTime(t/1000)\n\nI'm receiving error message\n\ncannot use t / 1000 (type\n  datastore.Time) as type int64 in\n  function argument\n\nAssignment from int64 to Time typed variable is successfull, but how can i cast it back?", "output": "do it like \ntime.SecondsToLocalTime(int64(t)/1000)\n\nSee more in the documentation about Conversions"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to count items in a Go map?\n\nQuestion:\nIf I want to count the items in the map structure, what statement should I use?\nI tried to use\nfor _, _ := range m {...}\n\nbut it seems the syntax is false.", "output": "Use len(m). From http://golang.org/ref/spec#Length_and_capacity\nlen(s)    string type      string length in bytes\n          [n]T, *[n]T      array length (== n)\n          []T              slice length\n          map[K]T          map length (number of defined keys)\n          chan T           number of elements queued in channel buffer\n\nHere are a couple examples ported from the now-retired SO documentation:\nm := map[string]int{}\nlen(m) // 0\n\nm[\"foo\"] = 1\nlen(m) // 1\n\nIf a variable points to a nil map, then len returns 0.\nvar m map[string]int\nlen(m) // 0\n\n\nExcerpted from Maps - Counting map elements. The original author was Simone Carletti. Attribution details can be found on the contributor page. The source is licenced under CC BY-SA 3.0 and may be found in the Documentation archive. Reference topic ID: 732 and example ID: 2528."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Using mgo for nested document fields\n\nQuestion:\nI am using Golang with mgo driver for mongodb. \nAccording to example at http://labix.org/mgo everything works great. But I can not find any documentation how mgo supports \"dot notation\" to be able to set and remove nested fields. So, how can I accesss nested fields?\nAnother question  is related to go Lang name convention. When I fill my structure with s.FindId(...).One(&doc) can doc have fields with lower case names like \"timer\" instead of \"Timer\"?\nDo mgo have possibility to get not structured document from mongo and just return map[string]string?", "output": "See mgo/bson docs on how to use lower case fields."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to run unit tests for code that uses App Engine services in Go?\n\nQuestion:\nI was told the best solution to run unit tests for code that uses App Engine services such as datastore or memcache was to run the development server in a child process, but I'm not sure how. Anybody successfully ran this kind of test and can share a solution?\nApp Engine SDK for Go uses the Python dev_appserver; see this thread.", "output": "You should check out Google App Engine Go testing library by Josh Marsh."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: No symbol table in Go?\n\nQuestion:\nGoogle's new language \"Go\" says on its website:\n\nthe language has been designed to be easy to analyze and can be parsed without a symbol table\n\nI'm certainly no expert on these matters, but I thought a symbol table was a basic construct common to all compilers for languages that use variables, and Go clearly uses variables. What am I not understanding?", "output": "Parsing means just figuring out the program structure: separating the module into statements/declarations, breaking expressions down to sub-expressions, etc. You end up with a tree structure, known as a \"parse tree\", or \"abstract syntax tree\" (AST).\nApparently, C++ requires a symbol table to do parsing.\nThis page discusses some reasons why C++ requires a symbol table for parsing.\nOf course, parsing is only a part of compilation, and you will need a symbol table to do a full compilation. \nHowever, parsing itself can be useful in writing analysis tools (e.g. which module imports which modules). So, simplifying the parsing process means it's easier to write code analysis tools."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to access other client connections from a Go WebSocket handler?\n\nQuestion:\nNote: I'm more interested in understanding general Go concepts/patterns, rather than solving this contrived example.\nThe Go (golang) WebSocket package provides a trivial echo server example, which condenses down to something like this:\nfunc EchoServer(ws *websocket.Conn) { io.Copy(ws, ws); }\n\nfunc main() {\n http.Handle(\"/echo\", websocket.Handler(EchoServer));\n http.ListenAndServe(\":12345\", nil);\n}\n\nThe server handles simultaneous connections, and I'm trying to upgrade it to a basic chat server by echoing the input to all connected clients.\nHow would I go about providing the EchoServer handler access to each of the open connections?", "output": "A quick little almost-functional example to give you an idea\nvar c = make(chan *websocket.Conn, 5) //5 is an arbitrary buffer size\nvar c2 = make(chan []byte, 5)\nfunc EchoServer(ws *websocket.Conn) {\n    buff := make([]byte, 256)\n    c <- ws\n    for size, e := ws.Read(buff); e == nil; size, e = ws.Read(buff) {\n        c2 <- buff[0:size]\n    }\n    ws.Close()\n}\nfunc main() {\n    go func() {\n        var somekindofstorage\n        for {\n            select {\n            case newC := <-c:\n                somekindofstorage.Add(newC)\n            case msg := <-c2:\n                for _, v := range somekindofstorage {\n                    if _, e := v.Write(msg); e != nil { //assuming the client disconnected on write errors\n                        somekindofstorage.Remove(v)\n                    }\n                }\n            }\n        }\n    }()\n    http.Handle(\"/echo\", websocket.Handler(EchoServer));\n    http.ListenAndServe(\":12345\", nil);\n}\n\nThis starts a goroutine that listens on two channels, one for new connections to add and one for messages to send to all active connection. somekindofstorage could be a map or a vector.\nEdit:\nAlternatively, you could just store all connections in a global map and write to each from EchoServer. But maps aren't designed to be accessed concurrently."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: What are some examples of Go interfaces?\n\nQuestion:\nI found an interesting blog post about Go.  \nI am trying to understand the concept of interfaces, but I find it very hard to do so from the code fragment in the blog post, and nearly impossible from the language specification. \nCan anyone point out a simple example of Go's interfaces in a working program?", "output": "It's a work-in-progress learning exercise, and certainly a poor example of good style, but here you go (spec).\nAdditionally, as a more exotic example, I made a post on the go-nuts mailing list regarding using interface{} for building functions that work with anonymous data (in this case, a \"ternary operation\" function):\npackage main\nimport \"fmt\";\nfunc Tern(exp bool, a interface{}, b interface{}) (interface{}) {\n    if exp { return a }\n    return b\n}\nfunc main() {\n    a := 7; b := 1;\n    result := Tern(a > b, a, b);\n    fmt.Printf(\"%d\\n\", result);\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to properly seed random number generator\n\nQuestion:\nI am trying to generate a random string in Go and here is the code I have written so far:\npackage main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n)\n\nfunc main() {\n    fmt.Println(randomString(10))\n}\n\nfunc randomString(l int) string {\n    var result bytes.Buffer\n    var temp string\n    for i := 0; i < l; {\n        if string(randInt(65, 90)) != temp {\n            temp = string(randInt(65, 90))\n            result.WriteString(temp)\n            i++\n        }\n    }\n    return result.String()\n}\n\nfunc randInt(min int, max int) int {\n    rand.Seed(time.Now().UTC().UnixNano())\n    return min + rand.Intn(max-min)\n}\n\nMy implementation is very slow. Seeding using time brings the same random number for a certain time, so the loop iterates again and again. How can I improve my code?", "output": "Each time you set the same seed, you get the same sequence. So of course if you're setting the seed to the time in a fast loop, you'll probably call it with the same seed many times.\nIn your case, as you're calling your randInt function until you have a different value, you're waiting for the time (as returned by Nano) to change.\nAs for all pseudo-random libraries, you have to set the seed only once, for example when initializing your program unless you specifically need to reproduce a given sequence (which is usually only done for debugging and unit testing).\nAfter that you simply call Intn to get the next random integer.\nMove the rand.Seed(time.Now().UTC().UnixNano()) line from the randInt function to the start of the main and everything will be faster. And lose the .UTC() call since:\n\nUnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC.\n\nNote also that I think you can simplify your string building:\npackage main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n)\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n    fmt.Println(randomString(10))\n}\n\nfunc randomString(l int) string {\n    bytes := make([]byte, l)\n    for i := 0; i < l; i++ {\n        bytes[i] = byte(randInt(65, 90))\n    }\n    return string(bytes)\n}\n\nfunc randInt(min int, max int) int {\n    return min + rand.Intn(max-min)\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Get name of function using reflection\n\nQuestion:\nI'm trying to use Go's reflection system to retrieve the name of a function but I get an empty string when calling the Name method on its type. Is this the expected behavior?\nThis is a simple example of how I approach the problem:\npackage main\n\nimport \"fmt\"\nimport \"reflect\"\n\nfunc main() {\n    typ := reflect.TypeOf(main)\n    name := typ.Name()\n    fmt.Println(\"Name of function\" + name)\n}", "output": "The solution is to use FuncForPc which returns a *Func.\nThis returns \"main.main\" :\npackage main\n\nimport \"fmt\"\nimport \"reflect\"\nimport \"runtime\"\n\n\nfunc main() {\n    name := runtime.FuncForPC(reflect.ValueOf(main).Pointer()).Name()\n    fmt.Println(\"Name of function : \" + name)\n}\n\nIf you want \"main\", just tokenize it."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: What is a \"value\" array?\n\nQuestion:\nIn C, the idea of an array is very straightforward—simply a pointer to the first element in a row of elements in memory, which can be accessed via pointer arithmetic/ the standard array[i] syntax.\nHowever, in languages like Google Go, \"arrays are values\", not pointers. What does that mean? How is it implemented?", "output": "In most cases they're the same as C arrays, but the compiler/interpreter hides the pointer from you. This is mainly because then the array can be relocated in memory in a totally transparent way, and so such arrays appear to have an ability to be resized.\nOn the other hand it is safer, because without a possibility to move the pointers you cannot make a leak."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How can I emulate Go's channels with Haskell?\n\nQuestion:\nI recently started reading about the Go programming language and I found the channel variables a very appealing concept. Is it possible to emulate the same concept in Haskell? Maybe to have a data type Channel a and a monad structure to enable mutable state and functions that work like the keyword go. \nI'm not very good in concurrent programming and a simple channel passing mechanism like this in Haskell would really make my life easier. \nEDIT\nPeople asked me to clarify what kind of Go's patterns I was interested in translating to Haskell. So Go has channel variables that are first class and can be passed around and returned by functions. I can read and write to these channels, and so communicate easily between routines that can run concurrently. Go also has a go keyword, that according to the language spec initiates the execution of a function concurrently as an independent thread and continues to execute the code without waiting. \nThe exact pattern I'm interested in is something like this (Go's syntax is weird - variables are declared by varName varType instead of the usual inverted way - but I think it is readable):\nfunc generateStep(ch chan int) {\n      //ch is a variable of type chan int, which is a channel that comunicate integers\n      for {\n          ch <- randomInteger() //just sends random integers in the channel \n      }\n\nfunc filter(input, output chan int) {\n      state int\n      for {\n          step <- input  //reads an int from the input channel\n          newstate := update(state, step) //update the variable with some update function\n          if criteria(newstate, state) {\n             state = newstate // if the newstate pass some criteria, accept the update\n          } \n          output <- state    //pass it to the output channel\n      } \n}\n\nfunc main() {\n    intChan := make(chan int) \n    mcChan  := make(chan int) \n    go generateStep(intChan)     // execute the channels concurrently\n    go filter(intChan, mcChan)\n    for i:=0; i<numSteps; i++  {\n        x <- mcChan        // get values from the filtered channel\n        accumulateStats(x)  // calculate some statistics\n    } \n    printStatisticsAbout(x)\n}\n\nMy primary interest is to do Monte Carlo simulations, in which I generate configurations sequentially by trying to modify the current state of the system and accepting the modification if it satisfies some criteria. \nThe fact the using those channel stuff I could write a very simple, readable and small Monte Carlo simulation that would run in parallel in my multicore processor really impressed me. \nThe problem is that Go have some limitations (specially, it lacks polymorphism in the way I'm accustomed to in Haskell), and besides that, I really like Haskell and don't wanna trade it away. So the question is if there's some way to use some mechanics that looks like the code above to do a concurrent simulation in Haskell easily. \nEDIT(2, context):\nI'm not learned in Computer Science, specially in concurrency. I'm just a guy who creates simple programs to solve simple problems in my daily research routine in a discipline not at all related to CS. I just find the way Haskell works interesting and like to use it to do my little chores. \nI never heard about alone pi-calculus or CSP channels. Sorry if the question seems ill posed, it's probably my huge-ignorance-about-the-matter's fault. \nYou are right, I should be more specific about what pattern in Go I'd like to replicate in Haskell, and I'll try to edit the question to be more specific. But don't expect profound theoretical questions. The thing is just that, from the few stuff I read and coded, it seems Go have a neat way to do concurrency (and in my case this just means that my job of making all my cores humming with numerical calculations is easier), and if I could use a similar syntax in Haskell I'd be glad.", "output": "I think what you are looking for is  Control.Concurrent.Chan from Base. I haven't found it to be any different from go's chans other then the obvious haskellifications. Channels aren't something that is special to go, have a look at the wiki page about it.\nChannels are part of a more general concept called communicating sequential processes (CSP), and if you want to do programming in the style of CSP in Haskell you might want to take a look at the Communicating Haskell Processes (CHP) package.\nCHP is only one way of doing concurrency in Haskell, take a look at the Haskellwiki concurrency page for more information. I think your use case might be best written using Data Parrallel Haskell, however that is currently a work in progress, so you might want to use something else for now."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to set and get fields in struct's method\n\nQuestion:\nAfter creating a struct like this:\ntype Foo struct {\n    name string\n}\n\nfunc (f Foo) SetName(name string) {\n    f.name = name\n}\n\nfunc (f Foo) GetName() string {\n    return f.name\n}\n\nHow do I create a new instance of Foo and set and get the name?\nI tried the following:\np := new(Foo)\np.SetName(\"Abc\")\nname := p.GetName()\n\nfmt.Println(name)\n\nNothing gets printed, because name is empty. So how do I set and get a field inside a struct?\nWorking playground", "output": "Commentary (and working) example:\npackage main\n\nimport \"fmt\"\n\ntype Foo struct {\n    name string\n}\n\n// SetName receives a pointer to Foo so it can modify it.\nfunc (f *Foo) SetName(name string) {\n    f.name = name\n}\n\n// Name receives a copy of Foo since it doesn't need to modify it.\nfunc (f Foo) Name() string {\n    return f.name\n}\n\nfunc main() {\n    // Notice the Foo{}. The new(Foo) was just a syntactic sugar for &Foo{}\n    // and we don't need a pointer to the Foo, so I replaced it.\n    // Not relevant to the problem, though.\n    p := Foo{}\n    p.SetName(\"Abc\")\n    name := p.Name()\n    fmt.Println(name)\n}\n\nTest it and take A Tour of Go to learn more about methods and pointers, and the basics of Go at all."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to determine an interface{} value's \"real\" type?\n\nQuestion:\nI have not found a good resource for using interface{} types. For example\npackage main\n\nimport \"fmt\"\n\nfunc weirdFunc(i int) interface{} {\n    if i == 0 {\n        return \"zero\"\n    }\n    return i\n}\nfunc main() {\n    var i = 5\n    var w = weirdFunc(5)\n\n    // this example works!\n    if tmp, ok := w.(int); ok {\n        i += tmp\n    }\n\n    fmt.Println(\"i =\", i)\n}\n\nDo you know of a good introduction to using Go's interface{}?\nspecific questions:\n\nhow do I get the \"real\" Type of w?\nis there any way to get the string representation of a type?\nis there any way to use the string representation of a type to\nconvert a value?", "output": "Your example does work. Here's a simplified version.\npackage main\n\nimport \"fmt\"\n\nfunc weird(i int) interface{} {\n    if i < 0 {\n        return \"negative\"\n    }\n    return i\n}\n\nfunc main() {\n    var i = 42\n    if w, ok := weird(7).(int); ok {\n        i += w\n    }\n    if w, ok := weird(-100).(int); ok {\n        i += w\n    }\n    fmt.Println(\"i =\", i)\n}\n\nOutput:\ni = 49\n\nIt uses Type assertions."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Speedup problems with go\n\nQuestion:\nI wrote a very simple program in go to test performances of a parallel program. I wrote a very simple program that factorizes a big semiprime number by division trials. Since no communications are involved, I expected an almost perfect speedup. However, the program seems to scale very badly.\nI timed the program with 1, 2, 4, and 8 processes, running on a 8 (real, not HT) cores computer, using the system timecommand. The number I factorized is \"28808539627864609\". Here are my results:\n\ncores  time (sec) speedup\n  1   60.0153      1\n  2   47.358       1.27\n  4   34.459       1.75\n  8   28.686       2.10\n\nHow to explain such bad speedups? Is it a bug in my program, or is it a problem with go runtime? How could I get better performances? I'm not talking about the algorithm by itself (I know there are better algorithms to factorize semiprime numbers), but about the way I parallelized it.\nHere is the source code of my program:\npackage main\n\nimport (\n    \"big\"\n    \"flag\"\n    \"fmt\"\n    \"runtime\"\n)\n\nfunc factorize(n *big.Int, start int, step int, c chan *big.Int) {\n\n    var m big.Int\n    i := big.NewInt(int64(start))\n    s := big.NewInt(int64(step))\n    z := big.NewInt(0)\n\n    for {\n        m.Mod(n, i)\n        if m.Cmp(z) == 0{\n            c <- i\n        }\n        i.Add(i, s)\n    }\n}\n\nfunc main() {\n    var np *int = flag.Int(\"n\", 1, \"Number of processes\")\n    flag.Parse()\n\n    runtime.GOMAXPROCS(*np)\n\n    var n big.Int\n    n.SetString(flag.Arg(0), 10) // Uses number given on command line\n    c := make(chan *big.Int)\n    for i:=0; i<*np; i++ {\n        go factorize(&n, 2+i, *np, c)\n    }\n    fmt.Println(<-c)\n}\n\n\nEDIT\nProblem really seems to be related to Mod function. Replacing it by Rem gives better but still imperfect performances and speedups. Replacing it by QuoRem gives 3 times faster performances, and perfect speedup. Conclusion: it seems memory allocation kills parallel performances in Go. Why? Do you have any references about this?", "output": "Big.Int methods generally have to allocate memory, usually to hold the result of the computation.  The problem is that there is just one heap and all memory operations are serialized.  In this program, the numbers are fairly small and the (parallelizable) computation time needed for things like Mod and Add is small compared to the non-parallelizable operations of repeatedly allocating all the tiny little bits of memory.\nAs far as speeding it up, there is the obvious answer of don't use big.Ints if you don't have to.  Your example number happens to fit in 64 bits.  If you plan on working with really big big numbers though, the problem will kind of go away on its own.  You will spend much more time doing computations, and the time spent in the heap will be relatively much less.\nThere is a bug in your program, by the way, although it's not related to performance.  When you find a factor and return the result on the channel, you send a pointer to the local variable i.  This is fine, except that you don't break out of the loop then.  The loop in the goroutine continues incrementing i and by the time the main goroutine gets around to fishing the pointer out of the channel and following it, the value is almost certain to be wrong."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: What does the asterisk do in \"Go\"?\n\nQuestion:\nI've been going through and trying to understand the examples on the Go website and I keep coming across a special asterisk character in examples like this:\ns := \"hello\"\nif s[1] != 'e' {\n    os.Exit(1)\n}\ns = \"good bye\"\nvar p *string = &s\n*p = \"ciao\"\n\nAlso, I just noticed, what's with the &s? Is it assignment by reference (I might be using PHP talk here)?", "output": "Im guessing it means the same as in C\np is a pointer to a string\nThe statement var p *string = &s would assign the address of the s object to p\nNext line *p = \"ciao\" would change the contents of s\nSee this link from the Language Design FAQ\nInterestingly, no pointer arithmetic\n\nWhy is there no pointer arithmetic?\nSafety. Without pointer arithmetic\nit's possible to create a language\nthat can never derive an illegal\naddress that succeeds incorrectly.\nCompiler and hardware technology have\nadvanced to the point where a loop\nusing array indices can be as\nefficient as a loop using pointer\narithmetic. Also, the lack of pointer\narithmetic can simplify the\nimplementation of the garbage\ncollector."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Accessing specific array indices using the go template library\n\nQuestion:\nSay i have a data structure like this:\ntype Foo struct {\n  Bar []struct {\n    FooBar string\n  }\n}\n\nAnd i fill it such that Bar has 3 elements. Now, using the template library, how can i access say the 3rd element's FooBar in that slice? I have tried the following with no success:\n{Foo.Bar[2].FooBar}\n{Foo.Bar.2.FooBar}\n\nNow, i know that i can use {.repeated section Foo.Bar} {FooBar} {.end}, but that gives me the value of foobar for each element, rather than just a specific one. I have googled and asked on irc to no avail...", "output": "I'm fairly certain this just isn't possible. Perhaps there's a way you could restructure your data so that it's all named fields.\nOr just write some more logic in your actual application. Array indexing is somewhat beyond the scope of the template package I would think."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to minimize the garbage collection in Go?\n\nQuestion:\nSome times you could want to avoid/minimize the garbage collector, so I want to be sure about how to do it.\nI think that the next one is correct:\n\nDeclare variables at the beginning of the function.\nTo use array instead of slice.\n\nAny more?", "output": "Avoiding garbage is relatively straight forward. You need to understand where the allocations are being made and see if you can avoid the allocation.\nFirst, declaring variables at the beginning of a function will NOT help. The compiler does not know the difference. However, human's will know the difference and it will annoy them.\nUse of an array instead of a slice will work, but that is because arrays (unless dereferenced) are put on the stack. Arrays have other issues such as the fact that they are passed by value (copied) between functions. Anything on the stack is \"not garbage\" since it will be freed when the function returns. Any pointer or slice that may escape the function is put on the heap which the garbage collector must deal with at some point.\nThe best thing you can do is avoid allocation. When you are done with large bits of data which you don't need, reuse them. This is the method used in the profiling tutorial on the Go blog. I suggest reading it.\nAnother example besides the one in the profiling tutorial: Lets say you have an slice of type []int named xs. You continually append to the []int until you reach a condition and then you reset it so you can start over. If you do xs = nil, you are now declaring the underlying array of the slice as garbage to be collected. Append will then reallocate xs the next time you use it. If instead you do xs = xs[:0], you are still resetting it but keeping the old array.\nFor the most part, trying to avoid creating garbage is premature optimization. For most of your code it does not matter. But you may find every once in a while a function which is called a great many times that allocates a lot each time it is run. Or a loop where you reallocate instead of reusing. I would wait until you see the bottle neck before going overboard."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Why does the Go image package cut+paste looping over pixels?\n\nQuestion:\nIf you look at the image package here http://golang.org/src/pkg/image/image.go you can see that the implementation of Opaque() for every image does the same thing, differing only in the pixel-specific logic.\nIs there a reason for this?  Would any general solution be less efficient?  Is it just an oversight?  Is there some limitation (I cannot see one) to the type system that would make a polymorphic [was: generic] approach difficult?\n[edit] The kind of solution I was thinking of (which does not need generics in the Java sense) would be like:\n\ntype ColorPredicate func(c image.Color) bool;\n\nfunc AllPixels (p *image.Image, q ColorPredicate) bool {\n  var r = p.Bounds()\n  if r.Empty() {\n    return true\n  }\n  for y := r.Min.Y; y < r.Max.Y; y++ {\n    for x := r.Min.X; x < r.Max.X; x++ {\n      if ! q(p.At(x,y)) {\n        return false\n      }\n    }\n  }\n  return true\n}\n\nbut I am having trouble getting that to compile (still very new to Go - it will compile with an image, but not with an image pointer!).\nIs that too hard to optimise?  (you would need to have function inlining, but then wouldn't any type checking be pulled out of the loop?).  Also, I now realise I shouldn't have used the word \"generic\" earlier - I meant it only in a generic (ha) way.", "output": "There is a limitation to the type system which prevents a general solution (or at least makes it very inefficient).\nFor example, the bodies of RGBA.Opaque and NRGBA.Opaque are identical, so you'd think that they could be factored out into a third function with a signature something like this:\nfunc opaque(pix []Color, stride int, rect Rectangle) bool\n\nYou'd like to call that function this way:\nfunc (p *RGBA) Opaque() bool {\n    return opaque([]Color(p.Pix), p.Stride, p.Rect)\n}\n\nBut you can't. p.Pix can't be converted to []Color because those types have different in-memory representations and the spec forbids it. We could allocate a new slice, convert each individual element of p.Pix, and pass that, but that would be very inefficient.\nObserve that RGBAColor and NRGBAColor have the exact same structure. Maybe we could factor out the function for just those two types, since the in-memory representation of the pixel slices is exactly the same:\nfunc opaque(pix []RGBAColor, stride int, rect Rectangle) bool\n\nfunc (p *NRGBA) Opaque() bool {\n    return opaque([]RGBAColor(p.Pix), p.Stride, p.Rect)\n}\n\nAlas, again this isn't allowed. This seems to be more of a spec/language issue than a technical one. I'm sure this has come up on the mailing list before, but I can't find a good discussion of it.\nThis seems like an area where generics would come in handy, but there's no solution for generics in Go yet."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Does Google's go-language address the problems in Paul's Graham's post 'Why Arc isn't Especially Object Oriented'?\n\nQuestion:\nDoes Google's Golang address the problems with languages addressed in Paul's Graham's post 'Why Arc isn't Especially Object Oriented'?", "output": "My initial feeling towards this is \"It is too soon to tell\"\n\n1) Object-oriented programming is exciting if you have a\n  statically-typed language   without\n  lexical closures or macros. To some\n  degree, it offers a way around these\n  limitations. (See Greenspun's Tenth\n  Rule.)\n\nGo supports Function literals (see docs) which if I am reading this correctly allow you to pass functions as params, whether defined elsewhere or created ad-hoc.\n\n2) Object-oriented programming is popular in big companies, because it\n  suits the way they write software. At\n  big companies, software tends to be\n  written by large (and frequently\n  changing) teams of mediocre\n  programmers. Object-oriented\n  programming imposes a discipline on\n  these programmers that prevents any\n  one of them from doing too much\n  damage. The price is that the\n  resulting code is bloated with\n  protocols and full of duplication.\n  This is not too high a price for big\n  companies, because their software is\n  probably going to be bloated and full\n  of duplication anyway.\n\nThis point is far to subjective to answer.  \n\n3) Object-oriented programming generates a lot of what looks like\n  work. Back in the days of fanfold,\n  there was a type of programmer who\n  would only put five or ten lines of\n  code on a page, preceded by twenty\n  lines of elaborately formatted\n  comments. Object-oriented programming\n  is like crack for these people: it\n  lets you incorporate all this\n  scaffolding right into your source\n  code. Something that a Lisp hacker\n  might handle by pushing a symbol onto\n  a list becomes a whole file of classes\n  and methods. So it is a good tool if\n  you want to convince yourself, or\n  someone else, that you are doing a lot\n  of work.\n\nSince go isn't a truly object oriented language, you can probably solve the problem in whatever fashon you are comfortable with.  \n\n4) If a language is itself an object-oriented program, it can be\n  extended by users. Well, maybe. Or\n  maybe you can do even better by\n  offering the sub-concepts of\n  object-oriented programming a la\n  carte. Overloading, for example, is\n  not intrinsically tied to classes.\n  We'll see.\n\nGo seems to have an interesting approach to objects, where you are not required to worry / develop large object trees.  It looks like the tools are present in the language to structure your data in an object oriented fashion without locking you in to a pure object oriented environment.\n\n5) Object-oriented abstractions map neatly onto the domains of certain\n  specific kinds of programs, like\n  simulations and CAD systems.\n\n..."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Printing to stdout causes blocked goroutine to run?\n\nQuestion:\nAs a silly basic threading exercise, I've been trying to implement the sleeping barber problem in golang. With channels this should be quite easy, but I've run into a heisenbug. That is, when I try to diagnose it, the problem disappears!\nConsider the following. The main() function pushes integers (or \"customers\") onto the shop channel. barber() reads the shop channel to cut \"customers'\" hair. If I insert a fmt.Print statement into the customer() function, the program runs as expected. Otherwise, barber() never cuts anyone's hair.\npackage main\n\nimport \"fmt\"\n\nfunc customer(id int, shop chan<- int) {\n    // Enter shop if seats available, otherwise leave\n    // fmt.Println(\"Uncomment this line and the program works\")\n    if len(shop) < cap(shop) {\n        shop <- id\n    }\n}\n\nfunc barber(shop <-chan int) {\n    // Cut hair of anyone who enters the shop\n    for {\n        fmt.Println(\"Barber cuts hair of customer\", <-shop)\n    }\n}\n\nfunc main() {\n    shop := make(chan int, 5) // five seats available\n    go barber(shop)\n    for i := 0; ; i++ {\n        customer(i, shop)\n    }\n}\n\nAny idea what's afoot?", "output": "The problem is the way Go's scheduler is implemented. The current goroutine can yield to other goroutines only when it makes a system call or a blocking channel operation. fmt.Println makes a system call, giving the goroutine an opportunity to yield. Otherwise it doesn't have one.\nIn practice this doesn't often matter, but for small problems like this it can sometimes crop up.\nAlso, a more idiomatic, less racy way of doing a non-blocking send on a channel is:\nfunc customer(id int, shop chan<- int) {\n    // Enter shop if seats available, otherwise leave\n    select {\n    case shop <- id:\n    default:\n    }\n}\n\nThe way you're doing it, a customer could end up waiting outside of the barber shop since by the time you actually do the send, len(shop) may have changed."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to set any value to interface{}\n\nQuestion:\nI have following code:\npackage main\n\nimport (\n   \"fmt\"\n)\n\ntype Point struct {\n    x,y int\n}\n\nfunc decode(value interface{}) {\n    fmt.Println(value) // -> &{0,0}\n\n    // This is simplified example, instead of value of Point type, there\n    // can be value of any type.\n    value = &Point{10,10}\n}\n\nfunc main() {\n    var p = new(Point)\n    decode(p)\n\n    fmt.Printf(\"x=%d, y=%d\", p.x, p.y) // -> x=0, y=0, expected x=10, y=10\n}\n\nI want to set value of any type to the value passed to decode function. Is it possible in Go, or I misunderstand something?\nhttp://play.golang.org/p/AjZHW54vEa", "output": "Generically, only using reflection:\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\ntype Point struct {\n    x, y int\n}\n\nfunc decode(value interface{}) {\n    v := reflect.ValueOf(value)\n    for v.Kind() == reflect.Ptr {\n        v = v.Elem()\n    }\n    n := reflect.ValueOf(Point{10, 10})\n    v.Set(n)\n}\n\nfunc main() {\n    var p = new(Point)\n    decode(p)\n    fmt.Printf(\"x=%d, y=%d\", p.x, p.y)\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Calling \"sed\" from exec.Command\n\nQuestion:\nI'm currently having trouble trying to run this code which is supposed to call the unix command sed to find and replace the string hello with goodbye in the file ./myfile.txt\nThis works fine if you run it from the command line, but if I try the same thing from my Go code....\ncommand := exec.Command(\"sed\", \"-e \\\"s/hello/goodbye/g\\\" ./myfile.txt\")\nresult,err := command.CombinedOutput()\nfmt.Println(string(result))\n\nBit I just keep on getting this output\nsed: -e expression #1, char 2: unknown command: `\"'\n\nIs there some sort of quote escaping going on or something to cause it to interpret the string wrong?\nAny help would be appreciated", "output": "I believe the following works:\ncommand := exec.Command(\"sed\", \"-e\",\"s/hello/goodbye/g\",\"myfile.txt\")"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to switch user in Go from username?\n\nQuestion:\nI have to execute this command with given username; in bash it'd be,\n$su devrim -c \"touch miki\"\n\ni guess, first i need to get the uid from the username and use setuid before doing ForkExec.\ncan u advice? how do i do this ? (ps: i don't have the uid, only username)\nfunc exec(cmd *Command, async bool) os.Error {\n    parts := strings.Fields(cmd.Command)\n    command := parts[0]\n\n    // cmd.Su holds the username \"root\" or \"myUser\"\n\n    pid, err := os.ForkExec(command, parts, os.Environ(), \"\", []*os.File{nil, cmd.Stdout, cmd.Stderr})\n    cmd.Pid = pid\n\n    if !async {\n        os.Wait(pid, 0)\n    }\n    return nil\n}\n\nedit: since that sysuser thing didn't work, and i saw that it's only parsing the /etc/passwd i decided to do it myself:\nfunc getUid(su string) int{\n\n    passwd,_ := os.Open(\"/etc/passwd\", os.O_RDONLY , 0600)\n\n    reader := bufio.NewReader(passwd)\n\n    for {\n        line,err := reader.ReadString('\\n')\n        if err != nil { \n            println(err.String()) \n            break\n        }\n\n        parsed := strings.Split(line,\":\",4)\n\n        if parsed[0] == su {\n            value,_ := strconv.Atoi(parsed[2])\n            return value\n        }\n    }\n\n    return -1\n}\n\ni'm not sure if all /etc/passwd's are formed the same accross *nix's, we use debian and ubuntu, proceed with care.", "output": "This package http://github.com/kless/go-sysuser can access the usernames, etc.\nThe syscall package has calls for Set/Get UID, etc."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: The go language exec.Command method execute failed\n\nQuestion:\npackage main\n\nimport (\n    \"os/exec\"\n    \"fmt\"\n)\n\nfunc main(){\n    cmd := exec.Command(\"find\", \"/home/d101270c/cbe\", \"-name\",\"*.log\", \">\", \"log.txt\")\n    fmt.Println(cmd)\n    err := cmd.Run()\n    if err != nil {\n        fmt.Printf(\"%s\\n\", err)\n        return\n    }\n}\n\nRun result:\n<1067 linux20 [d101270c] :/home/d101270c>uname -a\nLinux linux20 2.6.16.60-0.21-smp #1 SMP Tue May 6 12:41:02 UTC 2008 x86_64 x86_64 x86_64 GNU/Linux\n<1068 linux20 [d101270c] :/home/d101270c>tgo\n&{/usr/bin/find [find /home/d101270c/cbe -name *.log > log.txt] []  <nil> <nil> <nil> [] <nil> <nil> <nil> <nil> false [] [] [] [] <nil>}\nexit status 1\n\nThis command execute failed, and no log.txt exists.\nWhy?", "output": "You're passing find arguments like `>', which it doesn't understand, but the shell does. This works for me:\n(07:28) jnml@tsat:~/src/tmp/SO/11623232$ cat main.go \npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/exec\"\n)\n\nfunc main() {\n    //cmd := exec.Command(\"sh\", \"-c\", \"find /home/d101270c/cbe -name \\\\*.log > log.txt\")\n    cmd := exec.Command(\"sh\", \"-c\", \"find \"+os.Getenv(\"HOME\")+\"/src -name \\\\*.go > go.txt\")\n    fmt.Println(cmd)\n    err := cmd.Run()\n    if err != nil {\n        fmt.Printf(\"%s\\n\", err)\n        return\n    }\n}\n(07:29) jnml@tsat:~/src/tmp/SO/11623232$ go build main.go \n(07:29) jnml@tsat:~/src/tmp/SO/11623232$ ./main \n&{/bin/sh [sh -c find /home/jnml/src -name \\*.go > go.txt] []  <nil> <nil> <nil> [] <nil> <nil> <nil> <nil> false [] [] [] [] <nil>}\n(07:29) jnml@tsat:~/src/tmp/SO/11623232$ ls -l\ncelkem 1408\n-rw-r--r-- 1 jnml jnml    7845 2012-07-24 07:29 go.txt\n-rwxr-xr-x 1 jnml jnml 1428319 2012-07-24 07:29 main\n-rw-r--r-- 1 jnml jnml     332 2012-07-24 07:28 main.go\n(07:29) jnml@tsat:~/src/tmp/SO/11623232$ wc go.txt \n 131  131 7845 go.txt\n(07:29) jnml@tsat:~/src/tmp/SO/11623232$ tail go.txt \n/home/jnml/src/github.com/nsf/gocode/config.go\n/home/jnml/src/github.com/nsf/gocode/rpc.go\n/home/jnml/src/github.com/nsf/gocode/_gccgo/package.go\n/home/jnml/src/github.com/nsf/gocode/_goremote/goremote.go\n/home/jnml/src/github.com/nsf/gocode/scope.go\n/home/jnml/src/github.com/nsf/gocode/formatters.go\n/home/jnml/src/github.com/nsf/gocode/autocompletefile.go\n/home/jnml/src/github.com/nsf/gocode/decl.go\n/home/jnml/src/tmp/go/main.go\n/home/jnml/src/tmp/SO/11623232/main.go\n(07:29) jnml@tsat:~/src/tmp/SO/11623232$"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: what is the main difference between .net Async and google go light weight thread\n\nQuestion:\nWhen calling runtime.GOMAXPROCS(1) in go the runtime will only use one thread for all your goroutines. When doing io your goroutines will yield and let the other goroutines run on the same thread.\nThis seem very similar to me to how the .net Async CTP feature is doing cooperative concurrency if you are not using background thread.\nMy question is which advantage or drawback could you think of one methode over the other.", "output": "Making value judgements is always a tricky thing so I'll highlight 3 differences. You decide whether they fall into the \"pro\" or \"con\" bucket.\n\nWhile both Go and async allow you to write async code in a straightforward way, in .NET you have to be aware which part of your code is async and which one isn't (i.e. you have to explicitly use async/await keywords). In Go you don't need to know that - the runtime makes it \"just work\", there is no special syntax to mark async code.\nGo design doesn't require any special code in standard library. .NET required adding new code to the standard library for every async operation, essentially doubling API surface for those cases e.g. there's new async http download API and the old, non-async http download API has to remain for backwards compatibility.\nGo design and implementation is orders of magnitude simpler. A small piece of runtime code (scheduler) takes care of suspending goroutines that block on system calls and yielding to sleeping goroutines. There is no need for any special async support in standard library.\n\n.NET implementation first required adding the aforementioned new APIs. Furthermore .NET implementation is based on compiler rewriting code with async/await into an equivalent state machines. It's very clever but also rather complicated. The practical result was that the first async CTP had known bugs while Go's implementation was working pretty much from the beginning.\nUltimately, it doesn't really matter. async/await is the best way to write async code in .NET. Goroutines are the best way to get that in Go. Both are great, especially compared to alternatives in most other languages."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Google App Engine - Go vs. Python recommendations?\n\nQuestion:\nI'm looking into writing my first application of Google App Engine. C# is my 'native' language, and so writing the app in Java would of course be most logical. BUT, I'm a geek and would like to take to opportunity to learn something new.\nTherefore its a toss-up between Python and Go. \n\nDo you have a strong preference based on experience (ideally in the context of writing on App Engine).\nIf you've come from C# (or another similar language), how was the transition?", "output": "The recently-released Go runtime for App Engine is labelled experimental for a reason: Both Go and Go-on-appengine are new and in a state of change.\nIf you want to experiment with Go and running Go apps in the cloud, go for it. If you want to write a production app on App Engine, use Python or Java."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Variadic functions parameters pass-through\n\nQuestion:\nSituation:\nI'm trying to write a simple fmt.Fprintf wrapper which takes a variable number of arguments. This is the code:\nfunc Die(format string, args ...interface{}) {\n    str := fmt.Sprintf(format, args)\n    fmt.Fprintf(os.Stderr, \"%v\\n\", str)\n    os.Exit(1)\n}\n\nProblem:\nWhen I call it with Die(\"foo\"), I get the following output (instead of \"foo\"):\n\nfoo%!(EXTRA []interface {}=[])\n\n\nWhy is there \"%!(EXTRA []interface {}=[])\" after the \"foo\"?\nWhat is the correct way to create wrappers around fmt.Fprintf?", "output": "Variadic functions receive the arguments as a slice of the type. In this case your function receives a []interface{} named args. When you pass that argument to fmt.Sprintf, you are passing it as a single argument of type []interface{}. What you really want is to pass each value in args as a separate argument (the same way you received them). To do this you must use the ... syntax.\nstr := fmt.Sprintf(format, args...)\n\nThis is also explained in the Go specification here."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Permission Denied error calling external service from appengine go\n\nQuestion:\nI'm getting a permission denied error when I make a call to another web service from within my go code.\npart of the handler code on my server side go program:\nclient := http.Client{}\nif resp, err := client.Get(\"http://api.wipmania.com/\" + r.RemoteAddr); err != nil {\n    c.Errorf(\"Error getting location from ip: %s\", err.Error())\n}\n\nFrom the logs:\nError getting location from ip: Get http://api.wipmania.com/30.30.30.30: permission denied\n\nI saw a similar qn here.  Still unable to figure it out.  Can you please tell me what is the right way to do this and if any permissions have to be set on the appengine console?", "output": "App Engine applications can communicate with other applications and can access other resources on the web by fetching URLs. An app can use the URL Fetch service to issue HTTP and HTTPS requests and receive responses.\nTry:\nimport (\n    \"fmt\"\n    \"net/http\"\n\n    \"appengine\"\n    \"appengine/urlfetch\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    c := appengine.NewContext(r)\n    client := urlfetch.Client(c)\n    if resp, err := client.Get(\"http://api.wipmania.com/\" + r.RemoteAddr); err != nil {\n        c.Errorf(\"Error getting location from ip: %s\", err.Error())\n    }\n    // ...\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Is there any SFTP or SSH library for Go?\n\nQuestion:\nI can't seem to find any... it's a bit sad for a language positioned as networking-oriented one.", "output": "After sometime in exp/ssh, the official ssh package now resides in the crypto/ssh subrepo: http://code.google.com/p/go/source/browse?repo=crypto#hg%2Fssh"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Understanding goroutines\n\nQuestion:\nI'm trying to understand concurrency in Go.  In particular, I wrote this thread-unsafe program:\npackage main\n\nimport \"fmt\"\n\nvar x = 1\n\nfunc inc_x() { //test\n  for {\n    x += 1\n  }\n}\n\nfunc main() {\n  go inc_x()\n  for {\n    fmt.Println(x)\n  }\n}\n\nI recognize that I should be using channels to prevent race conditions with x, but that's not the point here.  The program prints 1 and then seems to loop forever (without printing anything more).  I would expect it to print an infinite list of numbers, possibly skipping some and repeating others due to the race condition (or worse -- printing the number while it is being updated in inc_x).\nMy question is:  Why does the program only print one line?\nJust to be clear:  I'm not using channels on purpose for this toy example.", "output": "There are a few things to keep in mind about Go's goroutines:\n\nThey are not threads in the sense of Java's or C++ threads\n\n\ngoroutines are more like greenlets\n\nThe go runtime multiplexes the goroutines across the system threads\n\nthe number of system threads is controlled by an environment variable GOMAXPROCS and defaults to 1 currently I think. This may change in the future\n\nThe way goroutines yield back to their current thread is controlled by several different constructs\n\n\nthe select statement can yield control back to the thread\nsending on a channel can yield control back to the thread\ndoing IO operations can yield control back to the thread\nruntime.Gosched() explicitly yields control back to the thread\n\n\nThe behavior you are seeing is because the main function never yields back to the thread and is instead involved in a busy loop and since there is only one thread the main loop has no place to run."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Go: Bitfields and bit packing\n\nQuestion:\nThe C language's bitfields provide a fairly convenient method of defining arbitrary-width fields within a structure (nevermind the problems with portability for a minute.) For example, here's a simple structure with a couple fields and a 'flag':\n#pragma pack(push,1)\nstruct my_chunk{\n\n    unsigned short fieldA: 16;\n    unsigned short fieldB: 15;\n    unsigned short fieldC:  1;\n};\n#pragma pop()\n\nAdding the #pragma statements packs this structure into a 32-bit word (ensuring that pointer manipulations of my_chunk pointers are aligned, for example, along with space savings).\nAccessing each field is syntactically very nice:\nstruct my_chunk aChunk;\naChunk.fieldA = 3;\naChunk.fieldB = 2;\naChunk.fieldC = 1;\n\nThe alternate way of doing this without the language's help is rather ugly and pretty much devolves into assembler. e.g. one solution is to have bitshift macros for each field you want to access:\n#define FIELD_A  0xFF00\n#define FIELD_B  0x00FE\n#define FIELD_C  0x0001\n\n#define get_field(p, f) ((*p)&f)\n#define set_field(p, f, v) (*p) = (v<<f) + (*p)&(~f)\n\n...\nset_field(&my_chunk, FIELD_A, 12345);\n\n.. or something roughly like that (for more formality, take a look at this)\nSo the question is, if I want to \"do\" bitfields in go, what is the best practice for doing so?", "output": "\"There are no current plans for struct bitfields in Go.\"\nYou could write a Go package to do this; no assembler is required."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: What does a >> mean in Go language?\n\nQuestion:\nI’m looking for information on Google’s Go language. In “A Tour of Go” they have this code:\nconst (\n    Big = 1<<100\n    Small = Big>>99\n)\n\nBut what do << and >>  mean?\nYou can see all of the code at http://tour.golang.org/#14", "output": "They are bitwise shift operators. x << y means x × 2y, while x >> y means x × 2−y or, equivalently, x ÷ 2y. These operators are generally used to manipulate the binary representation of a value, where, just like with a power of 10 in decimal, multiplying or dividing by a power of two has the effect of “shifting” the digits left or right, respectively:\n// Left shift:\n\n  13 *  2 ==    26 // decimal\n1101 * 10 == 11010 // binary (13 is 8 + 4 + 0 + 1)\n\n// Right shift (brackets denote discarded portion):\n\n  13 /  2 ==   6[.5] // decimal\n1101 / 10 == 110[.1] // binary\n\nBecause you are operating on integers and a right shift typically results in fractional values, there are a couple of ways to handle how the result of a right shift is rounded. In Go, right shift is a logical shift on unsigned values and an arithmetic shift on signed values. Logical shift always rounds toward zero, while arithmetic shift always rounds down, that is, toward −∞."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Go: range receiving only odd number of values from channel\n\nQuestion:\nI am running this code in the sandbox in http://tour.golang.org/\nI thought that once I launched the goroutine that ranges over the channel, all values I would send through would be printed.\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    c := make(chan int)\n\n    go (func(c chan int){\n        for v := range c {\n            fmt.Println(v)\n        }\n    })(c)\n\n    c <- 1\n    c <- 2\n    c <- 3\n    c <- 4   \n//  c <- 5  // uncomment to send more values\n//  c <- 6\n    close(c)\n}\n\nBut if I send an odd number of values (say, 1, 2 and 3), all values get printed.\nIf I send an even number of values(say, 1, 2, 3 and 4), the last one does not get printed.\nIt seems that the channel creation line:\n    c := make(chan int)\n\nChanges the behavior of the range expression when I add a buffer of different sizes:\n(I am sending 4 values)\n    c := make(chan int)     // prints 1,2,3\n    c := make(chan int, 1)  // same behavior, prints 1,2,3\n    c := make(chan int, 2)  // prints 1,2\n    c := make(chan int, 3)  // prints 1,2,3\n    c := make(chan int, 4)  // [no output]\n    c := make(chan int, 5)  // [no output]\n    c := make(chan int, 20) // [no output]\n\nWhy is it not receiving the last value when I send an even number?\n\nMore in this:\nI tested this offline also, compiling under 64 bit Linux.\nI changed the program a little:\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    c := make(chan int)\n    cc := make(chan int)\n\n    p := func (c chan int){\n      for v := range c {\n        fmt.Println(v)\n      }\n    }\n\n    go p(c)\n    go p(cc)\n\n    c <- 1\n    c <- 2\n    c <- 3\n    c <- 4\n//  c <- 5\n//  c <- 6\n    cc <- 1000\n//  cc <- 2000\n    close(c)\n    close(cc)\n}\n\nIf I decomment the line cc <- 2000 then everything gets printed.  But if I leave it commented out, I only get 1, 2 and 3.\nSeems like a timing issue.  I thought that the line cc <- 1000 would block the main function until all channels get read.", "output": "You are thinking of a close as being more like a send than it is, according to the memory model:\n\nThe closing of a channel happens before a receive that returns a zero\n  value because the channel is closed.\n\nSo you are guaranteed that those close statements will complete before their corresponding loops terminate.  Since you also know the close statements must happen after the last send on those channels (since they are in the same go-routine) you know that all but the last value sent on them will be guaranteed to print.  I think what you were expecting was the close to act more like a send, so that the loop is forced to print its last value.  If you replace the close statements with a send of -1, for example, this will guarantee all of the values (except the -1's, possibly) will get printed.  Whether or not the -1's get printed is not guaranteed.\nObviously this is a simplification of something, but I think the 'proper' way to write your example would be to use a sync.WaitGroup.  It's very easy and is perfect for firing off several go-routines and waiting for them all to complete.  Here is your code re-written to use a WaitGroup:\npackage main\n\nimport (\n  \"fmt\"\n  \"sync\"\n)\n\nfunc main() {\n  c := make(chan int)\n  cc := make(chan int)\n\n  var wg sync.WaitGroup\n\n  p := func(c chan int) {\n    for v := range c {\n      fmt.Println(v)\n    }\n    wg.Done()\n  }\n\n  wg.Add(2)\n  go p(c)\n  go p(cc)\n\n  c <- 1\n  c <- 2\n  c <- 3\n  c <- 4\n  cc <- 1000\n  cc <- 2000\n  close(c)\n  close(cc)\n  wg.Wait()\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Trying to launch an external editor from within a Go program\n\nQuestion:\nI am trying to figure out how to launch an external editor from within a Go program, wait for the user to close the editor, and then continue execution of the program. Based on this SO answer, I currently have this code:\npackage main\n\nimport (\n    \"log\"\n    \"os\"\n    \"os/exec\"\n)\n\nfunc main() {\n    fpath := os.TempDir() + \"/thetemporaryfile.txt\"\n    f, err := os.Create(fpath)\n    if err != nil {\n        log.Printf(\"1\")\n        log.Fatal(err)\n    }\n    f.Close()\n\n    cmd := exec.Command(\"vim\", fpath)\n    err = cmd.Start()\n    if err != nil {\n        log.Printf(\"2\")\n        log.Fatal(err)\n    }\n    err = cmd.Wait()\n    if err != nil {\n        log.Printf(\"Error while editing. Error: %v\\n\", err)\n    } else {\n        log.Printf(\"Successfully edited.\")\n    }\n\n}\n\nWhen I run the program, I get this:\nchris@DPC3:~/code/go/src/launcheditor$ go run launcheditor.go \n2012/08/23 10:50:37 Error while editing. Error: exit status 1\nchris@DPC3:~/code/go/src/launcheditor$ \n\nI have also tried using exec.Run() instead of exec.Start(), but that doesn't seem to work either (though it doesn't fail at the same place).\nI can get it to work if I use Gvim instead of Vim, but it refuses to work with both Vim and nano. I think it's related to Vim and nano running inside the terminal emulator instead of creating an external window.", "output": "Apparently, you have to set Stdin, Stdout and Stderr on the Cmd object to os.Std(in|out|err). Like this (assuming that the object is called cmd):\ncmd.Stdin = os.Stdin\ncmd.Stdout = os.Stdout\ncmd.Stderr = os.Stderr\n\nCredit for solving this goes to the guys on #go-nuts on freenode."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: To use package properly, how to arrange directory, file name, unit test file?\n\nQuestion:\nMy source files tree is like this:\n/src\n  /pkg\n    /foo\n      foo.go\n      foo_test.go\n\nInside foo.go:\npackage foo\n\nfunc bar(n int) {\n    ...\n}\n\ninside foo_test.go:\npackage foo\n\nfunc testBar(t *testing.T) {\n    bar(10)\n    ...\n}\n\nMy questions are:\n\nDoes package name relates to directory name, source file name?\nIf there is only one source file for a package, need I put it in a directory?\nShould I put foo.go and foo_test.go in the same package?\nIn the foo_test.go, as it's in the same package as foo.go, I didn't import foo. But when I compile foo_test.go with 6g, it says bar() is undefined. What should I do?", "output": "1 - The language spec says the following: \n\nA set of files sharing the same PackageName form the implementation of a package. An implementation may require that all source files for a package inhabit the same directory.\n\nSo it seems that there is no requirement on the naming of files / directories, but it would be safer to put all file that form a package in one directory.\n2 - Obviously the file must be in some directory. I assume you mean \"should I put it in a subdirectory of src?\" It seems to me based on the above quote that you could have all your files in src directly if you really wanted to.\n3 - Yes.\n4 - Use go test"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Implementing an overflow-free system stack in C90\n\nQuestion:\nI was just reading about how Google Go makes each thread with a reduced stack size by default, and then links to new stacks if an overflow would occur ( see page 16 in here ). I was wondering the best way to do that in C.\nI have to say I am no C expert, so there might be a better way to detect a Stack Overflow on C, but giving my ignorance, here's how I thought I would implement it:\nThe first thing I thought is that every time we have a fresh new stack, we get a stack variable's address, and with that we have roughly the starting stack address. Then we would need to be able to retrieve how much stack space the thread has. This would be possible if the thread isn't the main thread, but I have no idea how we would get this info on C.\nThen we would need to check (per function call, it could be) how much of the stack is already used, by retrieving current stack variable address. If we detect a possible stack overflow, we would need to have some way to create a new stack and link to the last one. The only way I thought it could be done in C would be to create a new thread to execute the function we want, and lock the current thread until the function returns its result.\nSo, would there be a cleaner/better way to implement this?", "output": "See GCC's split-stack capability.  I believe this was originally implemented to support Go.   It pretty much works as you suggest.\nEDIT: The commentary below discusses another system that does heap-allocation of activation records."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Go Syntax of calling a function with pointer receiver\n\nQuestion:\nIn Go, if I define a function with pointer as the receiver, shouldn't it allow call to the function from a pointer only? Why is it ok to call this function from the value itself and have the same effect. \nFor example, in following program: m1.reset() & m2.reset() have the same effect. Even though m1 is a value and m2 is a pointer.\nI'm a bit confused as there are two ways of doing the same thing and am not sure which one to follow. Though most of the code follows the convention of calling the function using pointer field. Am I missing something?\npackage main\n\n    import \"fmt\"\n\n    type MyStruct struct {\n        X int\n    }\n\n    func (m *MyStruct) reset() {\n        m.X = 0\n    }\n\n    func main() {\n        m1 := MyStruct{1}\n        m2 := &MyStruct{1}\n\n        fmt.Println(m1.X)\n        fmt.Println(m2.X)\n\n        m1.reset()\n        m2.reset()\n\n        fmt.Println(m1.X)\n        fmt.Println(m2.X)\n    }", "output": "Specs says:\n\nThe method set of the corresponding pointer type *T is the set of all methods with receiver *T or T (that is, it also contains the method set of T). \n\nThe next piece of necessary info about method calls says:\n\nA method call x.m() is valid if the method set of (the type of) x contains m and the argument list can be assigned to the parameter list of m. If x is addressable and &x's method set contains m, x.m() is shorthand for (&x).m().\n\nPut the two above things together and you get the behavior you see."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Go application server?\n\nQuestion:\nWould it be possible to leverage a design based on modular components running on an application server with Go platform?\nIs there a limitation that makes this design impossible with Go?", "output": "There is nothing similar to application server that are available in Java or .NET\nBut there is google AppEngine that supports Go\nThere is no way to load/unload code in Go like in Java or .NET\nYou can't compile go as library that you will load with another Go App.\nAnyway you can create Application server with Go. \nIt will have multiple processes and load/unload code by starting/stopping processes.\nAlso it may compile code on server by embedding some server specific code in module.\ne.g. such extra code may implement AppServer Inter Process Communication."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Checking if a channel has a ready-to-read value, using Go\n\nQuestion:\nHow do I check whether a channel has a value for me to read?\nI don't want to block when reading a channel. I want to see whether it has a value. If it does have one, I'll read it. If it doesn't have one (yet), I'll do something else and check back again later.", "output": "WARNING: This is no longer accurate, see the answer below.\nFrom the docs:\n\nIf a receive expression is used in an\n  assignment or initialization of the\n  form\nx, ok = <-ch\nx, ok := <-ch\nvar x, ok = <-ch\n\nthe receive operation becomes\n  non-blocking. If the operation can\n  proceed, the boolean variable ok will\n  be set to true and the value stored in\n  x; otherwise ok is set to false and x\n  is set to the zero value for its type"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Cannot compile Go language on Mac OS X 10.6.7\n\nQuestion:\nWhen following instructions on Getting Started - The Go Programming Language, I get the code and try to run the all.bash script.\nBut I get this error after a lot of other successful looking output:\nINSTALL FAIL net\nCGOPKGPATH= cgo --  cgo_bsd.go cgo_unix.go \ntouch _obj/_cgo_run\n6g  -o _go_.6 dial.go dnsmsg.go fd_darwin.go hosts.go ip.go ipsock.go iprawsock.go lookup.go net.go parse.go pipe.go sock.go tcpsock.go udpsock.go unixsock.go  newpollserver.go fd.go file.go dnsconfig.go dnsclient.go port.go  _obj/cgo_bsd.cgo1.go _obj/cgo_unix.cgo1.go _obj/_cgo_gotypes.go\n6c -FVw -I/Users/matryer/Work/go/pkg/darwin_amd64 -I . -o \"_cgo_defun.6\" _obj/_cgo_defun.c\ngcc -m64 -I . -g -fPIC -O2 -o _cgo_main.o -c   _obj/_cgo_main.c\ngcc -m64 -I . -g -fPIC -O2 -o cgo_bsd.cgo2.o -c   _obj/cgo_bsd.cgo2.c\ngcc -m64 -I . -g -fPIC -O2 -o cgo_unix.cgo2.o -c   _obj/cgo_unix.cgo2.c\ngcc -m64 -I . -g -fPIC -O2 -o _cgo_export.o -c   _obj/_cgo_export.c\ngcc -m64 -g -fPIC -O2 -o _cgo1_.o _cgo_main.o cgo_bsd.cgo2.o cgo_unix.cgo2.o _cgo_export.o  \ncgo -dynimport _cgo1_.o >_obj/_cgo_import.c_ && mv -f _obj/_cgo_import.c_ _obj/_cgo_import.c\n6c -FVw -I . -o \"_cgo_import.6\" _obj/_cgo_import.c\ncgo_bsd.go:5[_obj/cgo_bsd.cgo1.go:8]: undefined: _Cconst_AI_MASK\ncgo_unix.go:69[_obj/cgo_unix.cgo1.go:72]: undefined: _Cconst_AI_ALL\ncgo_unix.go:69[_obj/cgo_unix.cgo1.go:72]: undefined: _Cconst_AI_V4MAPPED\ncgo_unix.go:69[_obj/cgo_unix.cgo1.go:72]: undefined: _Cconst_AI_CANONNAME\nmake[1]: *** [_go_.6] Error 1\nmake: *** [net.install] Error 1\n\nHas anybody else seen this and fixed it?\nI am running Snow Leopard (10.6.7) build 10J869.", "output": "It's an open issue, relating to a new version of Xcode, for OS X 10.7 and 10.6.7.\nIssue 1881: cgo const error on OS X 10.7\nNOTE: Revision 142f0bc0d6e7 has been made to close issue 1881. To update Go for all changes up to and including this revision, run:\n$ cd $GOROOT/src\n$ hg pull\n$ hg update 142f0bc0d6e7\n$ ./all.bash"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to wait for threads with low latency in go?\n\nQuestion:\nI've been trying to create a simple event loop wrapper in Go. But I got stumped, how was I supposed to keep track of operations in the current thread?\nI wanted CurrentTick to run a function, and even if the calling function quits, not start the next tick until all functions run by CurrentTick quit. I thought I might use a mutex to monitor the number of threads, but I realized if I kept checking that over and over it would throttle the CPU. If I used time.Sleep it would be latent. How would you solve the problem?\npackage eventloop\n\nimport (\n    \"reflect\"\n)\n\ntype eventLoop *struct{\n    functions []reflect.Value\n    addFunc chan<-/*3*/ reflect.Value\n    mutex chan/*1*/ bool\n    threads int\n}\n\nfunc NewEventLoop() eventLoop {\n    var funcs chan reflect.Value\n    loop := eventLoop{\n        []Reflect.Value{},\n        funcs = make(chan reflect.Value, 3),\n        make(chan bool, 1),\n        0,\n    }\n    go func(){\n        for {\n            this.mutex <- 1\n            if threads == 0 {\n            }\n        }\n    }\n}\n\nfunc (this eventLoop) NextTick(f func()) {\n    this.addFunc <- reflect.ValueOf(f)\n}\n\nfunc (this eventLoop) CurrentTick(f func()) {\n    this.mutex <- 1\n    threads += 1\n    <-this.mutex\n    go func() {\n        f()\n        this.mutex <- 1\n        threads -= 1\n        <-this.mutex\n    }()\n}", "output": "If I understand your intent, I think you're overcomplicating things. I'd do it like this:\npackage eventloop\n\ntype EventLoop struct {\n    nextFunc chan func()\n    curFunc chan func()\n}\n\nfunc NewEventLoop() *EventLoop {\n    el := &EventLoop{\n        // Adjust the capacities to taste\n        make(chan func(), 3),\n        make(chan func(), 3),\n    }\n    go eventLoop(el)\n    return el\n}\n\nfunc (el *EventLoop) NextTick(f func()) {\n    el.nextFunc <- f\n}\n\nfunc (el *EventLoop) CurrentTick(f func()) {\n    el.curFunc <- f\n}\n\nfunc (el *EventLoop) Quit() {\n    close(el.nextFunc)\n}\n\nfunc eventLoop(el *EventLoop) {\n    for {\n        f, ok := <-el.nextFunc\n        if !ok {\n            return\n        }\n        f()\n\n        drain: for {\n            select {\n            case f := <-el.curFunc:\n                f()\n            default:\n                break drain\n            }\n        }\n    }\n}\n\nDepending on your use, you may need to add some synchronization to make sure all tasks in the loop finish before your program exits."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Array and slice data types\n\nQuestion:\nI found myself confused with the array and slice data types.\nFrom Go docs, arrays are described as follows:\n\nThere are major differences between the ways arrays work in Go and C. In Go,\n\nArrays are values. Assigning one array to another copies all the elements.\nIn particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it.\nThe size of an array is part of its type. The types [10]int and [20]int are distinct.\n\n\nFunctions:\n\nAs in all languages in the C family, everything in Go is passed by\n  value. That is, a function always gets a copy of the thing being\n  passed, as if there were an assignment statement assigning the value\n  to the parameter. For instance, passing an int value to a function\n  makes a copy of the int, and passing a pointer value makes a copy of\n  the pointer, but not the data it points to.\n\nWhy does sort.Ints(arrayValue) modify the passed variable when I declared it as an array, not as a slice?\nCode\nvar av = []int{1,5,2,3,7}\n\nfmt.Println(av)\nsort.Ints(av)\nfmt.Println(av)\nreturn\n\nOutput\n[1 5 2 3 7]\n[1 2 3 5 7]", "output": "See \"Slices: usage and internals\"\nvar av = []int{1,5,2,3,7}\n\nThat is a slice, not an array.\n\nA slice literal is declared just like an array literal, except you leave out the element count.\n\nThat explains why the sort function will modify the content of what is referenced by the slice.\nAs commented below by Kirk, sort.Ints  will give you an error if you passed it an array instead of a slice.\nfunc Ints(a []int)"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to read/write from/to a file using Go\n\nQuestion:\nI've been trying to learn Go on my own, but I've been stumped on trying read from and write to ordinary files.\nI can get as far as inFile, _ := os.Open(INFILE, 0, 0), but actually getting the content of the file doesn't make sense, because the read function takes a []byte as a parameter.\nfunc (file *File) Read(b []byte) (n int, err Error)", "output": "Let's make a Go 1-compatible list of all the ways to read and write files in Go.\nBecause file API has changed recently and most other answers don't work with Go 1. They also miss bufio which is important IMHO.\nIn the following examples I copy a file by reading from it and writing to the destination file.\nStart with the basics\npackage main\n\nimport (\n    \"io\"\n    \"os\"\n)\n\nfunc main() {\n    // open input file\n    fi, err := os.Open(\"input.txt\")\n    if err != nil {\n        panic(err)\n    }\n    // close fi on exit and check for its returned error\n    defer func() {\n        if err := fi.Close(); err != nil {\n            panic(err)\n        }\n    }()\n\n    // open output file\n    fo, err := os.Create(\"output.txt\")\n    if err != nil {\n        panic(err)\n    }\n    // close fo on exit and check for its returned error\n    defer func() {\n        if err := fo.Close(); err != nil {\n            panic(err)\n        }\n    }()\n\n    // make a buffer to keep chunks that are read\n    buf := make([]byte, 1024)\n    for {\n        // read a chunk\n        n, err := fi.Read(buf)\n        if err != nil && err != io.EOF {\n            panic(err)\n        }\n        if n == 0 {\n            break\n        }\n\n        // write a chunk\n        if _, err := fo.Write(buf[:n]); err != nil {\n            panic(err)\n        }\n    }\n}\n\nHere I used os.Open and os.Create which are convenient wrappers around os.OpenFile. We usually don't need to call OpenFile directly.\nNotice treating EOF. Read tries to fill buf on each call, and returns io.EOF as error if it reaches end of file in doing so. In this case buf will still hold data. Consequent calls to Read returns zero as the number of bytes read and same io.EOF as error. Any other error will lead to a panic.\nUsing bufio\npackage main\n\nimport (\n    \"bufio\"\n    \"io\"\n    \"os\"\n)\n\nfunc main() {\n    // open input file\n    fi, err := os.Open(\"input.txt\")\n    if err != nil {\n        panic(err)\n    }\n    // close fi on exit and check for its returned error\n    defer func() {\n        if err := fi.Close(); err != nil {\n            panic(err)\n        }\n    }()\n    // make a read buffer\n    r := bufio.NewReader(fi)\n\n    // open output file\n    fo, err := os.Create(\"output.txt\")\n    if err != nil {\n        panic(err)\n    }\n    // close fo on exit and check for its returned error\n    defer func() {\n        if err := fo.Close(); err != nil {\n            panic(err)\n        }\n    }()\n    // make a write buffer\n    w := bufio.NewWriter(fo)\n\n    // make a buffer to keep chunks that are read\n    buf := make([]byte, 1024)\n    for {\n        // read a chunk\n        n, err := r.Read(buf)\n        if err != nil && err != io.EOF {\n            panic(err)\n        }\n        if n == 0 {\n            break\n        }\n\n        // write a chunk\n        if _, err := w.Write(buf[:n]); err != nil {\n            panic(err)\n        }\n    }\n\n    if err = w.Flush(); err != nil {\n        panic(err)\n    }\n}\n\nbufio is just acting as a buffer here, because we don't have much to do with data. In most other situations (specially with text files) bufio is very useful by giving us a nice API for reading and writing easily and flexibly, while it handles buffering behind the scenes.\n\nNote: The following code is for older Go versions (Go 1.15 and before). Things have changed. For the new way, take a look at this answer.\nUsing ioutil\npackage main\n\nimport (\n    \"io/ioutil\"\n)\n\nfunc main() {\n    // read the whole file at once\n    b, err := ioutil.ReadFile(\"input.txt\")\n    if err != nil {\n        panic(err)\n    }\n\n    // write the whole body at once\n    err = ioutil.WriteFile(\"output.txt\", b, 0644)\n    if err != nil {\n        panic(err)\n    }\n}\n\nEasy as pie! But use it only if you're sure you're not dealing with big files."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: What do you use to write Go\n\nQuestion:\nI know its a bit too early, but I've been trying out Go (Google's Programming Language) and its kindof annoying to write code in gedit. \nSo, my question: What do you use to experiment with Go?", "output": "under $GOROOT/misc there are syntax highlighting files for emacs, vim, xcode and kate. Using any of these editors should do."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Need help understanding why select{} isn't blocking forever\n\nQuestion:\nI am working on an exercise in using channels to implement a queue. Specifically, I am trying to use the size of a channel to limit the number of simultaneous goroutines. To wit, I have written the following code:\npackage main\n\nimport \"fmt\"\nimport \"time\"\nimport \"math/rand\"\n\nfunc runTask (t string, ch *chan bool) {\n        start := time.Now()\n        fmt.Println(\"starting task\", t)\n        time.Sleep(time.Millisecond * time.Duration(rand.Int31n(1500))) // fake processing time\n        fmt.Println(\"done running task\", t, \"in\", time.Since(start))\n        <- *ch\n}\n\nfunc main() {\n        numWorkers := 3\n        files := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"}\n\n        activeWorkers := make(chan bool, numWorkers)\n\n        for _, f := range files {\n                activeWorkers <- true\n                fmt.Printf(\"activeWorkers is %d long.\\n\", len(activeWorkers))\n                go runTask(f, &activeWorkers)\n        }\n        select{}\n}\n\nRight now, the code crashes with:\nthrow: all goroutines are asleep - deadlock!\n\nMy expectation was that the call to select would block forever and let the goroutines terminate without a deadlock.\nSo I have a two-fold question: why isn't select blocking forever and, short of throwing in a time.Sleep() call after the for loop, how can I avoid deadlocks?\nCheers,\n-mtw", "output": "Arlen Cuss has already written a good answer. I just want to suggest another design for your work queue. Instead of limiting the number of entries your channel can buffer, you can also just spawn a limited number of worker goroutines which feels more natural imho. Something like that:\npackage main\n\nimport \"fmt\"\nimport \"time\"\nimport \"math/rand\"\n\nfunc runTask(t string) string {\n    start := time.Now()\n    fmt.Println(\"starting task\", t)\n    time.Sleep(time.Millisecond * time.Duration(rand.Int31n(1500))) // fake processing time\n    fmt.Println(\"done running task\", t, \"in\", time.Since(start))\n    return t\n}\n\nfunc worker(in chan string, out chan string) {\n    for t := range in {\n        out <- runTask(t)\n    }\n}\n\nfunc main() {\n    numWorkers := 3\n\n    // spawn workers\n    in, out := make(chan string), make(chan string)\n    for i := 0; i < numWorkers; i++ {\n        go worker(in, out)\n    }\n\n    files := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"}\n\n    // schedule tasks\n    go func() {\n        for _, f := range files {\n            in <- f\n        }\n    }()\n\n    // get results\n    for _ = range files {\n        <-out\n    }\n}\n\nYou can also use a sync.WaitGroup if you just want to wait until all tasks have been executed, but using an out channel has the advantage that you can aggregate the results later. For example if each tasks returns the number of words in that file, the final loop might be used to sum up all individual word counts."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: PANIC in default formatting with Go's log package\n\nQuestion:\nWhen logging in Go with log.Println, I frequently get\n2012/05/13 16:45:50 evaluating %v(PANIC=3)\n\nI'm not sure how to determine what I've done wrong, I assume that somewhere fmt.Println has caught a panic generated by one of my own Stringer interface implementations, so as not to crash my program due to logging failure.\nHow do I work out what's going on? Why am I getting this erroneous message?", "output": "You are right, there is a panic in a String method. But it has nothing to do with the log package. Println uses %v, and %v means running String method. Having a panic in the String method invokes catchPanic. Here in your output 3 is the value of your panic."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to export all package API names in GO\n\nQuestion:\nexport to api.txt file,such as\nfmt.Println(params...)\nnet.LookupIP(params...)\n...\n\nline by line\nI using this to IDE autocomplete", "output": "As others have said, gocode may well do what you want already. But anyway, to list the exported API of a package you can use go tool api <pkg>. e.g.\n$ go tool api runtime | grep func\n\npkg runtime, func Breakpoint()\npkg runtime, func CPUProfile() []byte\npkg runtime, func Caller(int) (uintptr, string, int, bool)\npkg runtime, func Callers(int, []uintptr) int\npkg runtime, func FuncForPC(uintptr) *Func\npkg runtime, func GC()\n..."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Get current time as formatted string in Go?\n\nQuestion:\nWhat's the best way to get the current timestamp in Go and convert to string? I need both date and time in eg. YYYYMMDDhhmmss format.", "output": "Use the time.Now() function and the time.Format() method.\nt := time.Now()\nfmt.Println(t.Format(\"20060102150405\"))\n\nprints out 20110504111515, or at least it did a few minutes ago. (I'm on Eastern Daylight Time.) There are several pre-defined time formats in the constants defined in the time package.\nYou can use time.Now().UTC() if you'd rather have UTC than your local time zone."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Special case treatment for the last element of a range in Google Go's text templates\n\nQuestion:\nI'm trying to write a string looking like this using go's template system:\n(p1, p2, p3), where p1, p2, ... comes from an array in the program. My problem is how to place the comma properly for the last (or the first) element.\nMy non working version that outputs (p1, p2, p3, ) looks like this:\npackage main\n\nimport \"text/template\"\nimport \"os\"\nfunc main() { \n    ip := []string{\"p1\", \"p2\", \"p3\"}\n    temp := template.New(\"myTemplate\")\n    temp,_ = temp.Parse(paramList)\n    temp.Execute(os.Stdout, ip)\n\n}\n\nconst paramList = \n`{{ $i := . }}({{ range $i }}{{ . }}, {{end}})`\n\nMy best clue so far is found here http://golang.org/pkg/text/template/ in the following statement:\nIf a \"range\" action initializes a variable, the variable is set to the successive elements of the iteration. Also, a \"range\" may declare two variables, separated by a comma:\n$index, $element := pipeline\n\nin which case $index and $element are set to the successive values of the array/slice index or map key and element, respectively. Note that if there is only one variable, it is assigned the element; this is opposite to the convention in Go range clauses.\nwhere it's suggested that the index \nThis suggests that it's possible to get hold of the index in the iteration but I just can't figure out what is meant with the range declaring two variables and where in the template those variables are supposed to be declared.", "output": "See this example from the go-nuts mailing list.  One key to this trick is that a template if is different than a Go language if.  A template can test for a value of zero, unlike the Go language that requires a boolean.  The magic is then {{if $index}},{{end}} where $index needs no declaration other than its appearance in the assignment."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to get a concurrent method\n\nQuestion:\nHow to get a concurrent method?\ntype test struct {\n    foo uint8\n    bar uint8\n}\n\nfunc NewTest(arg1 string) (*test, os.Error) {...}\n\nfunc (self *test) Get(str string) ([]byte, os.Error) {...}\n\nI think that all code for method Get() should be put inner of go func(), and then to use a channel.  \nfunc (self *test) Get(str string) ([]byte, os.Error) {\n    go func() {\n        // Code for this method.\n    }()\n}\n\n\nWould there be a problem if it's called another method from Get()? Or would it also has to be concurrent?", "output": "Take a look at the An example package section in The Go Language Specification, which is a complete Go package that implements a concurrent prime sieve, using go statements and channels.\nFor a detailed description of how it works, see the Go Tutorial section on Prime numbers. Also, look at the Go Tutorial section on Multiplexing.\nRead the Effective Go section on Concurrency.\nFinally, read the relevant sections of The Go Language Specification e.g. the sections on Go statements, Channel types, and Select statements.\nYes, you can call another method from your Get() method. Since a method call is not a concurrent go statement, it will execute immediately, before executing the next statement."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: unable to run goinstall\n\nQuestion:\ngoinstall go-tour.googlecode.com/hg/gotour\n\nRunning the above command give me the following message ..\ngoinstall: encoding/json: go/build: package could not be found locally\ngoinstall: code.google.com/p/go-tour/pic: cannot download: code.google.com/p/go-tour/pic\ngoinstall: code.google.com/p/go-tour/tree: cannot download: code.google.com/p/go-tour/tree\ngoinstall: code.google.com/p/go-tour/wc: cannot download: code.google.com/p/go-tour/wc\ngoinstall: os/exec: go/build: package could not be found locally\ngoinstall: net/http: go/build: package could not be found locally\n\nI know that there is problem with path setting .. i also checked this post\nexport PATH=$PATH:/home/sakthi/sakthig/code/my/go/go/bin\nexport GOROOT=/home/sakthi/sakthig/code/my/go/go\nexport GOPATH=$GOROOT/bin\n\nThis is my current path setting.. any help ?", "output": "The Go Tour project has been updated recently.\nThe Go weekly.2011-11-09 release renamed the json package to encoding/json.\nThe Go weekly.2011-12-14 release changed the naming for the go-tour package import paths from \"go-tour.googlecode.com/hg/tree\" to \"code.google.com/p/go-tour/tree\".\nUpdate to the Go weekly release (Keeping up with releases).\n$ cd $GOROOT/src\n$ hg pull\n$ hg update weekly\n$ ./all.bash\n\nThen install the go-tour/tree package.\n$ cd $GOROOT\n$ goinstall -v -fix code.google.com/p/go-tour/tree\ngoinstall: open /home/peter/go/goinstall.log: no such file or directory\ngoinstall: code.google.com/p/go-tour/tree: download\ngoinstall: cd / && /usr/bin/hg clone https://code.google.com/p/go-tour /home/peter/go/src/pkg/code.google.com/p/go-tour\ngoinstall: selecting tip\ngoinstall: cd /home/peter/go/src/pkg/code.google.com/p/go-tour && /usr/bin/hg update\ngoinstall: code.google.com/p/go-tour/tree: install\ngoinstall: cd /home/peter/go/src/pkg/code.google.com/p/go-tour/tree && /bin/bash gomake -f- install\n$"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Develop Go application that access to Windows\n\nQuestion:\nI am downloading MinGW to compile Go in Windows but, is it necessary any SDK to develop Go applications that access to Windows' system calls?", "output": "No. You don't need anything else than the standard library and windows compiler to run Go code on Windows. Including syscalls.\nCheck out the syscall package in Go's standard library."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Multiple files using template.ParseFiles in golang\n\nQuestion:\nFor example.go, I have\npackage main\n\nimport \"html/template\"\nimport \"net/http\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    t, _ := template.ParseFiles(\"header.html\", \"footer.html\")\n    t.Execute(w, map[string] string {\"Title\": \"My title\", \"Body\": \"Hi this is my body\"})\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}\n\nIn header.html:\nTitle is {{.Title}}\n\nIn footer.html:\nBody is {{.Body}}\n\nWhen going to http://localhost:8080/, I only see \"Title is My title\", and not the second file, footer.html. How can I load multiple files with template.ParseFiles? What's the most efficient way to do this?\nThanks in advance.", "output": "Only the first file is used as the main template. The other template files need to be included from the first like so:\nTitle is {{.Title}}\n{{template \"footer.html\" .}}\n\nThe dot after \"footer.html\" passes the data from Execute through to the footer template -- the value passed becomes . in the included template."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Strip out C-style comments from a []byte\n\nQuestion:\nall. I'm trying to write a wrapper for a particular type of config file, which is JSON encoded. Unfortunately, this file contains C-style comments, (// and /* */,) and these cause errors in json.Unmarshal. Is there a way force Unmarshal to ignore these comments, or otherwise remove them easily?\nI'm looking into regexp now, but I'm hoping there's an elegant solution that I, as a beginner in Go, might not be able to come up with in the course of a few minutes.", "output": "You'll have to strip out the comments, as the JSON specification does not allow comments. A regular expression can do the job.\npackage main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n\nvar bytes = []byte(`// this is a line comment\nthis is outside the comments\n/* this\n   is\n   a\n   multi-line\n   comment */`)\n\nfunc main() {\n    re := regexp.MustCompile(\"(?s)//.*?\\n|/\\\\*.*?\\\\*/\")\n    newBytes := re.ReplaceAll(bytes, nil)\n    fmt.Println(string(newBytes))\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Reading utf8-encoded data from a connection, using Go\n\nQuestion:\nI can easily write a string to a connection using io.WriteString.\nHowever, I can't seem to easily read a string from a connection. The only thing I can read from the connection are bytes, which, it seems, I must then somehow convert into a string.\nAssuming the bytes represent a utf8-encoded string, how would I convert them to string form?\n(Edit: alternatively, how could I simply read a string from a connection?)\nThanks!", "output": "You can just cast a slice of bytes into a string:\nvar foo []byte\nvar bar string = string(foo)\n\nThere is no encoding/decoding involved, because strings are just treated as arrays of bytes."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: A better concurrent prime number sieve in go\n\nQuestion:\nAfter looking at the prime number sieve code, and seeing how the\nconcurrent structure works, I found it to be extremely elegant.\nHowever, it's also extremely inefficient, and IIRC, equivalent to the\nO(n^2) operation of testing the divisibility of the number m by\ndividing it by every number less than m. I figure that I could instead\nmodify it to use the O(n^1.5) operation of checking the divisibility\nof m by dividing it by every number less than or equal to the sqrt(m).\nHowever, this turned out to be a lot harder than I anticipated.\nI know this is more of an algorithmics question, but it's also one\nextremely relevant to concurrency. How would one implement the\nO(n^1.5) version of the algorithm?", "output": "One place to look is stackoverflow, for example, the question Concurrent Prime Generator. Amongst the  answers is one that uses Go and channels."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Uncaught SyntaxError: Unexpected token <\n\nQuestion:\nI am running a server on go. When I access the localhost:8888/static/ajax.html, \nI get no errors. But when I just access localhost:8888 I get \nan error saying:\n\n\"Uncaught SyntaxError: Unexpected\n  token <\"\n\nBy default \"/\" serves ajax.html file, but doing so I don't get the \nexpected result. On the other hand on calling /static/ajax.html I am \ngetting the expected result without any errors. \nserver.go contains the following : \npackage main \nimport ( \n        \"http\" \n        \"flag\" \n) \n//var path = flag.String(\"storage\", \"/home/chinmay/work/jstree/\", \"Set storage directory, use absolute path\") \nvar root = flag.String(\"root\", \"/home/chinmay/work/ajax/\", \"Set root directory, use absolute path\") \nfunc temp(w http.ResponseWriter, r *http.Request){ \n        http.ServeFile(w,r,*root +\"ajax.html\") \n} \n\nfunc main(){ \n        http.HandleFunc(\"/\", temp) \n        http.Handle(\"/static/\", http.FileServer(*root, \"/static/\")) \n        http.ListenAndServe(\":8888\", nil) \n} \n\najax.html contains the following: \n<html> \n    <head> \n        <script type=\"text/javascript\" src=\"/static/jquery.js\"></script> \n        <script type=\"text/javascript\" src=\"/static/three/Three.js\"></script> \n        <script type=\"text/javascript\" src=\"/static/js/Detector.js\"></script> \n        <script type=\"text/javascript\" src=\"/static/js/RequestAnimationFrame.js\"></script> \n        <script type=\"text/javascript\" src=\"/static/js/Stats.js\"></script> \n        <script type=\"text/javascript\"> \n            $.ajaxSetup ({ \n                cache:false; \n            }) \n\n            $(\"#container\").ready(function(){ \n                $(\"button\").click(function(){ \n                    $.getScript(\"model.js\"); \n                }); \n            }); \n        </script> \n    </head> \n    <body> \n        <button>Use Ajax to get and then run a JavaScript</button> \n        <div id=\"container\"> \n        </div> \n    </body> \n</html> \n\nsocket.js : http://www.grideads.net/redmine/attachments/download/113/socket.js \nmodel.js : http://www.grideads.net/redmine/attachments/download/112/model.js", "output": "I did not decode the question, but a possible issue is the way you call your script\n$.getScript(\"model.js\") \n\nhttp://localhost:8888/  will call http://localhost:8888/model.js\nhttp://localhost:8888/static/ajax.html will call http://localhost:8888/static/model.js\nEDIT\nalso your model.js has an error on line 133\nfor( j = 0, jl = meshes.length; j < jl; j++ )\n\nthe proper for loop format is \nfor (variable=startvalue;variable<=endvalue;variable=variable+increment)\n\nj < jl; is extra, resulting in the \"Unexpected token <\" error message"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Go Programming Language Code Error\n\nQuestion:\nI try to write a simple code in GO, in which two go routine (Send and Receive) send each other integers. I give the code below. Can anybody help me why the output of this program is [no output]. Is there any silly mistake (sorry, I am new in GO) ?\npackage main\n\nfunc Send (in1 <-chan int, out1 chan<- int) {\n\n                i := 2 \n        out1 <- i \n    print(i, \"\\n\")\n}\n\nfunc Receive (in <-chan int, out chan<- int) {\n\n        i := <-in \n        print(i, \"\\n\")\n        out <- i \n}\n\n\nfunc main() {\n\n       for i := 0; i < 10; i++ {\n        ch1 := make(chan int)\n        ch := make(chan int) \n            go Send (ch1 , ch)\n        go Receive (ch , ch1)\n        ch = ch1\n        ch1 = ch\n        }\n\n}", "output": "How about this:\npackage main\n\nfunc Send (ch chan<- int) {\n    for i := 0; i < 10; i++ {\n      print(i, \" sending\\n\")\n      ch <- i\n    }\n}\n\nfunc Receive (ch <-chan int) {\n    for i := 0; i < 10; i++ {\n        print(<-ch, \" received\\n\")\n    }\n}\n\nfunc main() {\n   ch := make(chan int)\n   go Receive(ch)\n   Send(ch)\n}\n\nThe output of this when I run it on golang.org is:\n0 sending\n0 received\n1 sending\n2 sending\n1 received\n2 received\n3 sending\n4 sending\n3 received\n4 received\n5 sending\n6 sending\n5 received\n6 received\n7 sending\n8 sending\n7 received\n8 received\n9 sending\n\nI'm not sure why the 9 was never received.  There should be some way to sleep the main thread until the Receive goroutine has completed.  Also, it's inelegant that the receiver and the sender both know that they are going to send 10 numbers.  One of the goroutines should just shut off when the other has finished its work.  I'm not sure how to do that.\nEDIT1:\nHere is an implementation with two channels, and the go routines send ints back and forth between eachother.  One is designated as the responder, who only sends and int after it receives an int.  The responder simply adds two to the int he receives, and then sends it back.\npackage main\n\nfunc Commander(commands chan int, responses chan int) {\n    for i := 0; i < 10; i++ {\n      print(i, \" command\\n\")\n      commands <- i\n      print(<-responses, \" response\\n\");\n    }\n    close(commands)\n}\n\nfunc Responder(commands chan int, responses chan int) {\n    for {\n        x, open := <-commands\n        if !open {\n            return;\n        }\n        responses <- x + 2\n    }\n}\n\nfunc main() {\n   commands := make(chan int)\n   responses := make(chan int)\n   go Commander(commands, responses)\n   Responder(commands, responses)\n}\n\nThe output when I run it on golang.org is:\n0 command\n2 response\n1 command\n3 response\n2 command\n4 response\n3 command\n5 response\n4 command\n6 response\n5 command\n7 response\n6 command\n8 response\n7 command\n9 response\n8 command\n10 response\n9 command\n11 response"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Optional Parameters in Go?\n\nQuestion:\nCan Go have optional parameters? Or can I just define two different functions with the same name and a different number of arguments?", "output": "Go does not have optional parameters nor does it support method overloading:\n\nMethod dispatch is simplified if it\n  doesn't need to do type matching as\n  well. Experience with other languages\n  told us that having a variety of\n  methods with the same name but\n  different signatures was occasionally\n  useful but that it could also be\n  confusing and fragile in practice.\n  Matching only by name and requiring\n  consistency in the types was a major\n  simplifying decision in Go's type\n  system."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How do I translate the following threading model from C++ to go?\n\nQuestion:\nIn my C++ project, I have a large, GB binary file on disk that I read into memory for read-only calculations.\nMy current C++ implementation involves reading the entire chunk into memory once and then spawning threads to read from the chunk in order to do various calculations (mutex-free and runs quickly).  Technically, each thread really only needs a small part of the file at a time, so in the future, I may change this implementation to use mmap(), especially if the file gets too big.  I've noticed this gommap lib so I think I should be covered going forward.\nWhat approach should I take to translate my current C++ threading model (one large chunk of read-only memory) into a go threading model, keeping run-time efficiency in mind? \ngoroutines?  alternatives?", "output": "I'm sure this answer will cop a lot of heat but here goes:\nYou won't get reduced running time by switching to Go, especially if your code is already mutex free. Go doesn't guarantee efficient balancing of goroutines, and will not currently make best use of the available cores. The generated code is slower than C++. Go's current strengths are in clean abstractions, and concurrency, not parallelism.\nReading the entire file up front isn't particular efficient if you then have to go and backtrack through memory. Parts of the file you won't use again until much later will be dropped from the cache, only to be reloaded again later. You should consider memory mapping if your platform will allow it, so that pages are loaded from disk as they're required.\nIf there is any intense inter-routine communication, or dependencies between the data you should try to make the algorithm single threaded. It's difficult to say without knowing more about the routines you're applying to the data, but it does sound possible that you've pulled out threads prematurely in the hope to get a magic performance boost.\nIf you're unable to rely on memory mapping due to file size, or other platform constraints, you should consider making use of the pread call, thereby reusing a single file descriptor, and only reading as required.\nAs always, the following rule applies to optimization. You must profile. You must check that changes you make from a working solution, are improving things. Very often you'll find that memory mapping, threading and other shenanigans have no noticeable effect on performance whatsoever. It's also an uphill battle if you're switching away from C or C++.\nAlso, you should spawn goroutines to handle each part of the file, and reduce the results of the calculations through a channel. Make sure to set GOMAXPROCS to an appropriate value."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: go / geany : configure build command\n\nQuestion:\nWith an old version of go I could configure the build command in geany as\ngo install \"%d\"\n\nBut it seems that in Go1 you cannot provide to go install the absolute path.\nSo I'd like to have a command enabling me in geany to run\ngo install mypackagename\n\nwhen my edited file is\n/some/path/to/my/project/go/src/mypackagename/editedfile.go\n\nWhat can I put in the settings to obtain that ?\nPlease consider that I'm a linux noob and that there may exist a trivial solution using a combination of standard shell commands.", "output": "I would try something like\ncd \"%d\" && go install\n\nIt changes the current working directory to the directory supplied by geany and\nruns go install if the directory change was successful.\nThis only works if geany is executing the build commands in a shell. Without that,\nthere's no cd (the shell provides it as an inbuilt command) and this solution won't work.\nYour only hope then is, to configure the current working dir for the build process in geany."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How to embed file for later parsing execution use\n\nQuestion:\nI am essentially trying to walk through a folder of html files. I want to embed them into the binary file and be able to parse them upon request for template execution purposes. (Please excuse me if im not wording this properly).\nAny ideas, tips, tricks or better way of accomplishing this is much appreciated.\n// Template Files\ntype TempFiles struct {\n    Files map[string]string\n}\n\n// Loop through view files and load them\nfunc LoadTempFiles() {\n    t := new(TempFiles)\n\n    // Load template files\n    filepath.Walk(\"application/views\", func(path string, info os.FileInfo, err error) error {\n    if !info.IsDir() {\n        content, _ := ioutil.ReadFile(path)\n        t.Files[path] = string(content)\n    }\n    return nil\n    })\n}\n\nfunc ViewTemp(w http.ResponseWriter, path string) {\n    t := new(TempFiles)\n\n    temp, err := template.New().Parse(t.Files[path])\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    } else {\n        temp.Execute(w, nil)\n    }\n}", "output": "Go now has builtin support for this:\npackage main\n\nimport (\n   \"embed\"\n   \"os\"\n)\n\n//go:embed *.html\nvar content embed.FS\n\nfunc main() {\n   b, e := content.ReadFile(\"index.html\")\n   if e != nil {\n      panic(e)\n   }\n   os.Stdout.Write(b)\n}\n\nhttps://golang.org/pkg/embed"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: When writing a single package meant to be used as a command, which is idiomatic: name all identifiers as private or name all identifiers as public?\n\nQuestion:\nIn Go, public names start with an upper case letter and private names start with a lower case letter.\nI'm writing a program that is not library and is a single package. Is there any Go idiom that stipulates whether my identifiers should be all public or all private? I do not plan on using this package as a library or as something that should be imported from another Go program.\nI can't think of any reason why I'd want a mixture. It \"feels\" like going all private is the proper choice.\n\nI don't think I got any concrete answer, but Nate was closest with telling me to think of \"exporting vs non-exporting\" instead of \"public and private\".\nThis leads me to believe that not exporting anything is the best approach. In the worst case scenario, if I end up importing code from my application in another package, I will have to rethink what should be exported and what shouldn't be. Which is a good thing IMO.", "output": "If you are attempting to adjust your mindset to be more Go idiomatic, you should stop thinking of variables, functions, and methods as public or private.  The more accurate term is exported or not exported.  It definitely has a more C like feel to it.\nAs others have stated exporting really isn't needed for application program code.  If for organizational reasons you decide to break your program up into packages, you could use sub-packages.  At work we've decided to do just this.  We have:\nprojectgopath/src/projectname\n                  projectname/subcomponent1\n                  projectname/subcomponent2\n\nSo far I am really liking this structure.  It aids in separation of concerns, but does not go to the extent of making a package outside of the main project.  The intent is clear.  The sub-package's intended use is for this program only...\nThe new go build and go install commands seem to deal very well with it.  We group components together in packages and expose only the necessary bits via exports."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: How can I get os.Errno from os.Error? Other ways to use os.Timeout?\n\nQuestion:\nThe net.Conn interface provides the SetTimeout methods and I am supposed to check the returned error with os.Timeout. However I see no way of calling os.Timeout on the returned os.Error.\n(The os.Error I've got is read unix @: Resource temporarily unavailable which seem to consists of two parts: description of the function which timed out and the strerror description of the EAGAIN. I've tried err == os.EAGAIN and it doesn't work, probably because of the extra information in os.Error).", "output": "You need to do a type assertion. Let's say kon is type net.Conn and you read into buffer buf. Then:\nif numread, err := kon.Read(buf); err != nil {\n    if val, ok := err.(os.Errno); ok {\n        if val.Timeout() {\n            println(\"Connection to:\", kon.RemoteAddr().String(), \"timed out.\")\n        }\n    }\n}\n\nThat's of course only a gist of the idea. In practice you probably want to do something more elegant (aka more RL complexleete) and consider more cases at once with Type switches."}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Parse multiple integers from a string in Go?\n\nQuestion:\nsorry for the title , i don't know how to say that \ni have a questions about this code \nfunc ip2long(ip string) (ret int64) {\n  p:= strings.Split(ip, \".\")\n  n, _:= strconv.Atoi(p[0])\n  ret += int64(n)*16777216 \n  n, _= strconv.Atoi(p[1])\n  ret += int64(n)*65536 \n  n, _= strconv.Atoi(p[2])\n  ret += int64(n)*256\n  n, _= strconv.Atoi(p[3])\n  ret += int64(n)\n\n  return \n}\n\nI want to convert an ip address to integer number \nyou see I have wrote such ugly code\nfirst retrive number from strconv.Atoi then convert it to int64 \nHow to simplify this ?", "output": "If you want to parse multiple integers from a string, try the Sscanf function, like this:\nfunc main() {\n    var ip [4] uint32\n    addr := \"192.168.0.1\"\n    _, err := fmt.Sscanf(addr, \"%d.%d.%d.%d\", &ip[0], &ip[1], &ip[2], &ip[3])\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(ip)\n    fmt.Println(ip[0]<<24 + ip[1]<<16 + ip[2]<<8 + ip[3])\n}"}
{"instruction": "You are an expert Go language developer. Answer the following question clearly and accurately.", "input": "Title: Best way to organize a Go interface\n\nQuestion:\nIts been a long time since I have programmed in C++, but I know that in C++ the classes are organized into .h files and .cpp files. Also many other languages benefit from splitting up code into logical groupings within a directory structure to improve organization.\nWell I am trying to learn Go now and I was reading over the Go for C++ Programmers article when I came upon interfaces. The article explains that interfaces in Go essentially take the place of classes, and shows how to set them up pretty well.\nWhat I am trying to figure out though is how should I organize an interface into files? For instance, should the interface be in one file while the implementation is in another?\nmyInterface.go\ntype myInterface interface {\n    get() int\n    set(i int)\n}\n\nmyImplementation.go\ntype myType struct { i int }\nfunc (p *myType) set(i int) { p.i = i }\nfunc (p *myType) get() int { return p.i }\n\nMy code here may be wrong since I do not completely know what I am doing yet (and if I am wrong please correct me), but would this be the best way to set this up? Im having a very hard time trying to wrap my head around how to organize code in Go so any help is appreciated!\nMetropolis", "output": "There is no need to put types and interfaces in separate files. The things exported from each package are what matters and you denote those by beginning the name with a capital letter. In C & co. what goes into a header file matters because that's the thing “imported” (included). In Go it's the package that is imported, and it doesn't matter how its contents are organised into different source files (it won't be visible to the importer anyhow).\nMy personal recommendation is to avoid creating unnecessary files. If the code is relatively short, keep it in one file. If it's long, then consider splitting off parts for which it feels natural to do so (e.g. interface + related functions that would be probably form a separate class if you were doing it in Java or C++). Don't split off anything just for the sake of separating definitions from code; it doesn't make sense in Go even though it does in C."}
